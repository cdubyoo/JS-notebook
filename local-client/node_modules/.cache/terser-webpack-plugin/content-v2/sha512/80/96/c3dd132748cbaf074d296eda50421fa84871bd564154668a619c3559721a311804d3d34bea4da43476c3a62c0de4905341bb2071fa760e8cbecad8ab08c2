{"code":"(this.webpackJsonpjbook=this.webpackJsonpjbook||[]).push([[206],{374:function(e,t){!function(e){var t=e.languages.javascript[\"template-string\"],n=t.pattern.source,r=t.inside.interpolation,a=r.inside[\"interpolation-punctuation\"],o=r.pattern.source;function i(t,r){if(e.languages[t])return{pattern:RegExp(\"((?:\"+r+\")\\\\s*)\"+n),lookbehind:!0,greedy:!0,inside:{\"template-punctuation\":{pattern:/^`|`$/,alias:\"string\"},\"embedded-code\":{pattern:/[\\s\\S]+/,alias:t}}}}function s(e,t){return\"___\"+t.toUpperCase()+\"_\"+e+\"___\"}function p(t,n,r){var a={code:t,grammar:n,language:r};return e.hooks.run(\"before-tokenize\",a),a.tokens=e.tokenize(a.code,a.grammar),e.hooks.run(\"after-tokenize\",a),a.tokens}function l(t){var n={};n[\"interpolation-punctuation\"]=a;var o=e.tokenize(t,n);if(3===o.length){var i=[1,1];i.push.apply(i,p(o[1],e.languages.javascript,\"javascript\")),o.splice.apply(o,i)}return new e.Token(\"interpolation\",o,r.alias,t)}function u(t,n,r){var a=e.tokenize(t,{interpolation:{pattern:RegExp(o),lookbehind:!0}}),i=0,u={},c=p(a.map((function(e){if(\"string\"===typeof e)return e;for(var n,a=e.content;-1!==t.indexOf(n=s(i++,r)););return u[n]=a,n})).join(\"\"),n,r),g=Object.keys(u);return i=0,function e(t){for(var n=0;n<t.length;n++){if(i>=g.length)return;var r=t[n];if(\"string\"===typeof r||\"string\"===typeof r.content){var a=g[i],o=\"string\"===typeof r?r:r.content,s=o.indexOf(a);if(-1!==s){++i;var p=o.substring(0,s),c=l(u[a]),f=o.substring(s+a.length),y=[];if(p&&y.push(p),y.push(c),f){var v=[f];e(v),y.push.apply(y,v)}\"string\"===typeof r?(t.splice.apply(t,[n,1].concat(y)),n+=y.length-1):r.content=y}}else{var d=r.content;Array.isArray(d)?e(d):e([d])}}}(c),new e.Token(r,c,\"language-\"+r,t)}e.languages.javascript[\"template-string\"]=[i(\"css\",/\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),i(\"html\",/\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),i(\"svg\",/\\bsvg/.source),i(\"markdown\",/\\b(?:md|markdown)/.source),i(\"graphql\",/\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),t].filter(Boolean);var c={javascript:!0,js:!0,typescript:!0,ts:!0,jsx:!0,tsx:!0};function g(e){return\"string\"===typeof e?e:Array.isArray(e)?e.map(g).join(\"\"):g(e.content)}e.hooks.add(\"after-tokenize\",(function(t){t.language in c&&function t(n){for(var r=0,a=n.length;r<a;r++){var o=n[r];if(\"string\"!==typeof o){var i=o.content;if(Array.isArray(i))if(\"template-string\"===o.type){var s=i[1];if(3===i.length&&\"string\"!==typeof s&&\"embedded-code\"===s.type){var p=g(s),l=s.alias,c=Array.isArray(l)?l[0]:l,f=e.languages[c];if(!f)continue;i[1]=u(p,f,c)}}else t(i);else\"string\"!==typeof i&&t([i])}}}(t.tokens)}))}(Prism)}}]);","name":"static/js/206.2b83d5b4.chunk.js","map":{"version":3,"sources":["static/js/206.2b83d5b4.chunk.js"],"names":["this","push","374","module","exports","Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","RegExp","lookbehind","greedy","template-punctuation","alias","embedded-code","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","apply","splice","Token","tokenizeEmbedded","_tokens","interpolation","placeholderCounter","placeholderMap","embeddedTokens","map","token","placeholder","interpolationExpression","content","indexOf","join","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","filter","Boolean","supportedLanguages","js","typescript","ts","jsx","tsx","stringContent","value","add","findTemplateStrings","l","type","embedded"],"mappings":"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"},"input":"(this[\"webpackJsonpjbook\"] = this[\"webpackJsonpjbook\"] || []).push([[206],{\n\n/***/ 374:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js\n\n  var templateLiteralPattern = templateString.pattern.source;\n  var interpolationObject = templateString.inside['interpolation'];\n  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n  var interpolationPattern = interpolationObject.pattern.source;\n  /**\n   * Creates a new pattern to match a template string with a special tag.\n   *\n   * This will return `undefined` if there is no grammar with the given language id.\n   *\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\n   * @param {string} tag The regex pattern to match the tag.\n   * @returns {object | undefined}\n   * @example\n   * createTemplate('css', /\\bcss/.source);\n   */\n\n  function createTemplate(language, tag) {\n    if (!Prism.languages[language]) {\n      return undefined;\n    }\n\n    return {\n      pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'template-punctuation': {\n          pattern: /^`|`$/,\n          alias: 'string'\n        },\n        'embedded-code': {\n          pattern: /[\\s\\S]+/,\n          alias: language\n        }\n      }\n    };\n  }\n\n  Prism.languages.javascript['template-string'] = [// styled-jsx:\n  //   css`a { color: #25F; }`\n  // styled-components:\n  //   styled.h1`color: red;`\n  createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), // html`<p></p>`\n  // div.innerHTML = `<p></p>`\n  createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n  createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n  createTemplate('markdown', /\\b(?:md|markdown)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n  createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source), // vanilla template string\n  templateString].filter(Boolean);\n  /**\n   * Returns a specific placeholder literal for the given language.\n   *\n   * @param {number} counter\n   * @param {string} language\n   * @returns {string}\n   */\n\n  function getPlaceholder(counter, language) {\n    return '___' + language.toUpperCase() + '_' + counter + '___';\n  }\n  /**\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n   *\n   * @param {string} code\n   * @param {any} grammar\n   * @param {string} language\n   * @returns {(string|Token)[]}\n   */\n\n\n  function tokenizeWithHooks(code, grammar, language) {\n    var env = {\n      code: code,\n      grammar: grammar,\n      language: language\n    };\n    Prism.hooks.run('before-tokenize', env);\n    env.tokens = Prism.tokenize(env.code, env.grammar);\n    Prism.hooks.run('after-tokenize', env);\n    return env.tokens;\n  }\n  /**\n   * Returns the token of the given JavaScript interpolation expression.\n   *\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n   * @returns {Token}\n   */\n\n\n  function tokenizeInterpolationExpression(expression) {\n    var tempGrammar = {};\n    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n    /** @type {Array} */\n\n    var tokens = Prism.tokenize(expression, tempGrammar);\n\n    if (tokens.length === 3) {\n      /**\n       * The token array will look like this\n       * [\n       *     [\"interpolation-punctuation\", \"${\"]\n       *     \"...\" // JavaScript expression of the interpolation\n       *     [\"interpolation-punctuation\", \"}\"]\n       * ]\n       */\n      var args = [1, 1];\n      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n      tokens.splice.apply(tokens, args);\n    }\n\n    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n  }\n  /**\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n   *\n   * This function has 3 phases:\n   *\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\n   *    The placeholder will have the syntax of a identify of the target language.\n   * 2. Tokenize the code with placeholders.\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n   *    tokenized as two tokens by the grammar of the embedded language.\n   *\n   * @param {string} code\n   * @param {object} grammar\n   * @param {string} language\n   * @returns {Token}\n   */\n\n\n  function tokenizeEmbedded(code, grammar, language) {\n    // 1. First filter out all interpolations\n    // because they might be escaped, we need a lookbehind, so we use Prism\n\n    /** @type {(Token|string)[]} */\n    var _tokens = Prism.tokenize(code, {\n      'interpolation': {\n        pattern: RegExp(interpolationPattern),\n        lookbehind: true\n      }\n    }); // replace all interpolations with a placeholder which is not in the code already\n\n\n    var placeholderCounter = 0;\n    /** @type {Object<string, string>} */\n\n    var placeholderMap = {};\n\n    var embeddedCode = _tokens.map(function (token) {\n      if (typeof token === 'string') {\n        return token;\n      } else {\n        var interpolationExpression = token.content;\n        var placeholder;\n\n        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {}\n\n        placeholderMap[placeholder] = interpolationExpression;\n        return placeholder;\n      }\n    }).join(''); // 2. Tokenize the embedded code\n\n\n    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\n\n    var placeholders = Object.keys(placeholderMap);\n    placeholderCounter = 0;\n    /**\n     *\n     * @param {(Token|string)[]} tokens\n     * @returns {void}\n     */\n\n    function walkTokens(tokens) {\n      for (var i = 0; i < tokens.length; i++) {\n        if (placeholderCounter >= placeholders.length) {\n          return;\n        }\n\n        var token = tokens[i];\n\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          var placeholder = placeholders[placeholderCounter];\n          var s = typeof token === 'string' ? token :\n          /** @type {string} */\n          token.content;\n          var index = s.indexOf(placeholder);\n\n          if (index !== -1) {\n            ++placeholderCounter;\n            var before = s.substring(0, index);\n            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n            var after = s.substring(index + placeholder.length);\n            var replacement = [];\n\n            if (before) {\n              replacement.push(before);\n            }\n\n            replacement.push(middle);\n\n            if (after) {\n              var afterTokens = [after];\n              walkTokens(afterTokens);\n              replacement.push.apply(replacement, afterTokens);\n            }\n\n            if (typeof token === 'string') {\n              tokens.splice.apply(tokens, [i, 1].concat(replacement));\n              i += replacement.length - 1;\n            } else {\n              token.content = replacement;\n            }\n          }\n        } else {\n          var content = token.content;\n\n          if (Array.isArray(content)) {\n            walkTokens(content);\n          } else {\n            walkTokens([content]);\n          }\n        }\n      }\n    }\n\n    walkTokens(embeddedTokens);\n    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n  }\n  /**\n   * The languages for which JS templating will handle tagged template literals.\n   *\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n   */\n\n\n  var supportedLanguages = {\n    'javascript': true,\n    'js': true,\n    'typescript': true,\n    'ts': true,\n    'jsx': true,\n    'tsx': true\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (!(env.language in supportedLanguages)) {\n      return;\n    }\n    /**\n     * Finds and tokenizes all template strings with an embedded languages.\n     *\n     * @param {(Token | string)[]} tokens\n     * @returns {void}\n     */\n\n\n    function findTemplateStrings(tokens) {\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          continue;\n        }\n\n        var content = token.content;\n\n        if (!Array.isArray(content)) {\n          if (typeof content !== 'string') {\n            findTemplateStrings([content]);\n          }\n\n          continue;\n        }\n\n        if (token.type === 'template-string') {\n          /**\n           * A JavaScript template-string token will look like this:\n           *\n           * [\"template-string\", [\n           *     [\"template-punctuation\", \"`\"],\n           *     (\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n           *         or\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n           *                                  It also has an alias which is the language of the embedded code.\n           *     ),\n           *     [\"template-punctuation\", \"`\"]\n           * ]]\n           */\n          var embedded = content[1];\n\n          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n            // get string content\n            var code = stringContent(embedded);\n            var alias = embedded.alias;\n            var language = Array.isArray(alias) ? alias[0] : alias;\n            var grammar = Prism.languages[language];\n\n            if (!grammar) {\n              // the embedded language isn't registered.\n              continue;\n            }\n\n            content[1] = tokenizeEmbedded(code, grammar, language);\n          }\n        } else {\n          findTemplateStrings(content);\n        }\n      }\n    }\n\n    findTemplateStrings(env.tokens);\n  });\n  /**\n   * Returns the string content of a token or token stream.\n   *\n   * @param {string | Token | (string | Token)[]} value\n   * @returns {string}\n   */\n\n  function stringContent(value) {\n    if (typeof value === 'string') {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.map(stringContent).join('');\n    } else {\n      return stringContent(value.content);\n    }\n  }\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/User/Desktop/jbook/node_modules/prismjs/components/prism-js-templates.js"],"names":["Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","undefined","RegExp","lookbehind","greedy","alias","filter","Boolean","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","push","apply","splice","Token","tokenizeEmbedded","_tokens","placeholderCounter","placeholderMap","embeddedCode","map","token","interpolationExpression","content","placeholder","indexOf","join","embeddedTokens","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","supportedLanguages","add","findTemplateStrings","l","type","embedded","stringContent","value"],"mappings":"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","file":"x","sourcesContent":["(function (Prism) {\n\n\tvar templateString = Prism.languages.javascript['template-string'];\n\n\t// see the pattern in prism-javascript.js\n\tvar templateLiteralPattern = templateString.pattern.source;\n\tvar interpolationObject = templateString.inside['interpolation'];\n\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n\tvar interpolationPattern = interpolationObject.pattern.source;\n\n\n\t/**\n\t * Creates a new pattern to match a template string with a special tag.\n\t *\n\t * This will return `undefined` if there is no grammar with the given language id.\n\t *\n\t * @param {string} language The language id of the embedded language. E.g. `markdown`.\n\t * @param {string} tag The regex pattern to match the tag.\n\t * @returns {object | undefined}\n\t * @example\n\t * createTemplate('css', /\\bcss/.source);\n\t */\n\tfunction createTemplate(language, tag) {\n\t\tif (!Prism.languages[language]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'template-punctuation': {\n\t\t\t\t\tpattern: /^`|`$/,\n\t\t\t\t\talias: 'string'\n\t\t\t\t},\n\t\t\t\t'embedded-code': {\n\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\talias: language\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\n\tPrism.languages.javascript['template-string'] = [\n\t\t// styled-jsx:\n\t\t//   css`a { color: #25F; }`\n\t\t// styled-components:\n\t\t//   styled.h1`color: red;`\n\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n\n\t\t// html`<p></p>`\n\t\t// div.innerHTML = `<p></p>`\n\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n\n\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n\t\tcreateTemplate('svg', /\\bsvg/.source),\n\n\t\t// md`# h1`, markdown`## h2`\n\t\tcreateTemplate('markdown', /\\b(?:md|markdown)/.source),\n\n\t\t// gql`...`, graphql`...`, graphql.experimental`...`\n\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n\n\t\t// vanilla template string\n\t\ttemplateString\n\t].filter(Boolean);\n\n\n\t/**\n\t * Returns a specific placeholder literal for the given language.\n\t *\n\t * @param {number} counter\n\t * @param {string} language\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(counter, language) {\n\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';\n\t}\n\n\t/**\n\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n\t *\n\t * @param {string} code\n\t * @param {any} grammar\n\t * @param {string} language\n\t * @returns {(string|Token)[]}\n\t */\n\tfunction tokenizeWithHooks(code, grammar, language) {\n\t\tvar env = {\n\t\t\tcode: code,\n\t\t\tgrammar: grammar,\n\t\t\tlanguage: language\n\t\t};\n\t\tPrism.hooks.run('before-tokenize', env);\n\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);\n\t\tPrism.hooks.run('after-tokenize', env);\n\t\treturn env.tokens;\n\t}\n\n\t/**\n\t * Returns the token of the given JavaScript interpolation expression.\n\t *\n\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n\t * @returns {Token}\n\t */\n\tfunction tokenizeInterpolationExpression(expression) {\n\t\tvar tempGrammar = {};\n\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n\n\t\t/** @type {Array} */\n\t\tvar tokens = Prism.tokenize(expression, tempGrammar);\n\t\tif (tokens.length === 3) {\n\t\t\t/**\n\t\t\t * The token array will look like this\n\t\t\t * [\n\t\t\t *     [\"interpolation-punctuation\", \"${\"]\n\t\t\t *     \"...\" // JavaScript expression of the interpolation\n\t\t\t *     [\"interpolation-punctuation\", \"}\"]\n\t\t\t * ]\n\t\t\t */\n\n\t\t\tvar args = [1, 1];\n\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n\n\t\t\ttokens.splice.apply(tokens, args);\n\t\t}\n\n\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n\t}\n\n\t/**\n\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n\t *\n\t * This function has 3 phases:\n\t *\n\t * 1. Replace all JavaScript interpolation expression with a placeholder.\n\t *    The placeholder will have the syntax of a identify of the target language.\n\t * 2. Tokenize the code with placeholders.\n\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n\t *    tokenized as two tokens by the grammar of the embedded language.\n\t *\n\t * @param {string} code\n\t * @param {object} grammar\n\t * @param {string} language\n\t * @returns {Token}\n\t */\n\tfunction tokenizeEmbedded(code, grammar, language) {\n\t\t// 1. First filter out all interpolations\n\n\t\t// because they might be escaped, we need a lookbehind, so we use Prism\n\t\t/** @type {(Token|string)[]} */\n\t\tvar _tokens = Prism.tokenize(code, {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: RegExp(interpolationPattern),\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t});\n\n\t\t// replace all interpolations with a placeholder which is not in the code already\n\t\tvar placeholderCounter = 0;\n\t\t/** @type {Object<string, string>} */\n\t\tvar placeholderMap = {};\n\t\tvar embeddedCode = _tokens.map(function (token) {\n\t\t\tif (typeof token === 'string') {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\tvar interpolationExpression = token.content;\n\n\t\t\t\tvar placeholder;\n\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { }\n\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t}).join('');\n\n\n\t\t// 2. Tokenize the embedded code\n\n\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n\n\n\t\t// 3. Re-insert the interpolation\n\n\t\tvar placeholders = Object.keys(placeholderMap);\n\t\tplaceholderCounter = 0;\n\n\t\t/**\n\t\t *\n\t\t * @param {(Token|string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction walkTokens(tokens) {\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tif (placeholderCounter >= placeholders.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {\n\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];\n\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);\n\n\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t++placeholderCounter;\n\n\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\treplacement.push(before);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\tvar afterTokens = [after];\n\t\t\t\t\t\t\twalkTokens(afterTokens);\n\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\ti += replacement.length - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar content = token.content;\n\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\twalkTokens(content);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twalkTokens([content]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalkTokens(embeddedTokens);\n\n\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n\t}\n\n\t/**\n\t * The languages for which JS templating will handle tagged template literals.\n\t *\n\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n\t */\n\tvar supportedLanguages = {\n\t\t'javascript': true,\n\t\t'js': true,\n\t\t'typescript': true,\n\t\t'ts': true,\n\t\t'jsx': true,\n\t\t'tsx': true,\n\t};\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (!(env.language in supportedLanguages)) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * Finds and tokenizes all template strings with an embedded languages.\n\t\t *\n\t\t * @param {(Token | string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction findTemplateStrings(tokens) {\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar content = token.content;\n\t\t\t\tif (!Array.isArray(content)) {\n\t\t\t\t\tif (typeof content !== 'string') {\n\t\t\t\t\t\tfindTemplateStrings([content]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (token.type === 'template-string') {\n\t\t\t\t\t/**\n\t\t\t\t\t * A JavaScript template-string token will look like this:\n\t\t\t\t\t *\n\t\t\t\t\t * [\"template-string\", [\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"],\n\t\t\t\t\t *     (\n\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n\t\t\t\t\t *         or\n\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.\n\t\t\t\t\t *     ),\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"]\n\t\t\t\t\t * ]]\n\t\t\t\t\t */\n\n\t\t\t\t\tvar embedded = content[1];\n\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n\t\t\t\t\t\t// get string content\n\t\t\t\t\t\tvar code = stringContent(embedded);\n\n\t\t\t\t\t\tvar alias = embedded.alias;\n\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;\n\n\t\t\t\t\t\tvar grammar = Prism.languages[language];\n\t\t\t\t\t\tif (!grammar) {\n\t\t\t\t\t\t\t// the embedded language isn't registered.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfindTemplateStrings(content);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfindTemplateStrings(env.tokens);\n\t});\n\n\n\t/**\n\t * Returns the string content of a token or token stream.\n\t *\n\t * @param {string | Token | (string | Token)[]} value\n\t * @returns {string}\n\t */\n\tfunction stringContent(value) {\n\t\tif (typeof value === 'string') {\n\t\t\treturn value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn value.map(stringContent).join('');\n\t\t} else {\n\t\t\treturn stringContent(value.content);\n\t\t}\n\t}\n\n}(Prism));\n"]}}