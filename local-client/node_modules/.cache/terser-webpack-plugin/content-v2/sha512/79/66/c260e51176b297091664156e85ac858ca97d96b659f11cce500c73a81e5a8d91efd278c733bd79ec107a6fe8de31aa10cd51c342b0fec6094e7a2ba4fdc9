{"code":"(this.webpackJsonpjbook=this.webpackJsonpjbook||[]).push([[236],{404:function(e,n){!function(e){function n(e){return RegExp(\"(\\\\()\"+e+\"(?=[\\\\s\\\\)])\")}function a(e){return RegExp(\"([\\\\s([])\"+e+\"(?=[\\\\s)])\")}var t=\"[-+*/_~!@$%^=<>{}\\\\w]+\",s=\"(\\\\()\",i=\"(?=\\\\))\",r={heading:{pattern:/;;;.*/,alias:[\"comment\",\"title\"]},comment:/;.*/,string:{pattern:/\"(?:[^\"\\\\]|\\\\.)*\"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\\s])/,symbol:RegExp(\"`\"+t+\"'\")}},\"quoted-symbol\":{pattern:RegExp(\"#?'\"+t),alias:[\"variable\",\"symbol\"]},\"lisp-property\":{pattern:RegExp(\":\"+t),alias:\"property\"},splice:{pattern:RegExp(\",@?\"+t),alias:[\"symbol\",\"variable\"]},keyword:[{pattern:RegExp(\"(\\\\()(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)(?=\\\\s)\"),lookbehind:!0},{pattern:RegExp(\"(\\\\()(?:for|do|collect|return|finally|append|concat|in|by)(?=\\\\s)\"),lookbehind:!0}],declare:{pattern:n(\"declare\"),lookbehind:!0,alias:\"keyword\"},interactive:{pattern:n(\"interactive\"),lookbehind:!0,alias:\"keyword\"},boolean:{pattern:a(\"(?:t|nil)\"),lookbehind:!0},number:{pattern:a(\"[-+]?\\\\d+(?:\\\\.\\\\d*)?\"),lookbehind:!0},defvar:{pattern:RegExp(\"(\\\\()def(?:var|const|custom|group)\\\\s+\"+t),lookbehind:!0,inside:{keyword:/^def[a-z]+/,variable:RegExp(t)}},defun:{pattern:RegExp(\"(\\\\()(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+\"+t+\"\\\\s+\\\\([\\\\s\\\\S]*?\\\\)\"),lookbehind:!0,inside:{keyword:/^(?:cl-)?def\\S+/,arguments:null,function:{pattern:RegExp(\"(^\\\\s)\"+t),lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:RegExp(\"(\\\\()lambda\\\\s+\\\\((?:&?\"+t+\"\\\\s*)*\\\\)\"),lookbehind:!0,inside:{keyword:/^lambda/,arguments:null,punctuation:/[()]/}},car:{pattern:RegExp(s+t),lookbehind:!0},punctuation:[/(?:['`,]?\\(|[)\\[\\]])/,{pattern:/(\\s)\\.(?=\\s)/,lookbehind:!0}]},o={\"lisp-marker\":RegExp(\"&[-+*/_~!@$%^=<>{}\\\\w]+\"),rest:{argument:{pattern:RegExp(t),alias:\"variable\"},varform:{pattern:RegExp(s+t+\"\\\\s+\\\\S[\\\\s\\\\S]*\"+i),lookbehind:!0,inside:{string:r.string,boolean:r.boolean,number:r.number,symbol:r.symbol,punctuation:/[()]/}}}},l=\"\\\\S+(?:\\\\s+\\\\S+)*\",p={pattern:RegExp(\"(\\\\()[\\\\s\\\\S]*(?=\\\\))\"),lookbehind:!0,inside:{\"rest-vars\":{pattern:RegExp(\"&(?:rest|body)\\\\s+\"+l),inside:o},\"other-marker-vars\":{pattern:RegExp(\"&(?:optional|aux)\\\\s+\"+l),inside:o},keys:{pattern:RegExp(\"&key\\\\s+\"+l+\"(?:\\\\s+&allow-other-keys)?\"),inside:o},argument:{pattern:RegExp(t),alias:\"variable\"},punctuation:/[()]/}};r.lambda.inside.arguments=p,r.defun.inside.arguments=e.util.clone(p),r.defun.inside.arguments.inside.sublist=p,e.languages.lisp=r,e.languages.elisp=r,e.languages.emacs=r,e.languages[\"emacs-lisp\"]=r}(Prism)}}]);","name":"static/js/236.a04cbcf2.chunk.js","map":{"version":3,"sources":["static/js/236.a04cbcf2.chunk.js"],"names":["this","push","404","module","exports","Prism","simple_form","name","RegExp","primitive","pattern","symbol","par","endpar","language","heading","alias","comment","string","greedy","inside","argument","quoted-symbol","lisp-property","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","lisp-marker","rest","varform","forms","arglist","rest-vars","other-marker-vars","keys","util","clone","sublist","languages","lisp","elisp","emacs"],"mappings":"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"},"input":"(this[\"webpackJsonpjbook\"] = this[\"webpackJsonpjbook\"] || []).push([[236],{\n\n/***/ 404:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  // Functions to construct regular expressions\n  // simple form\n  // e.g. (interactive ... or (interactive)\n  function simple_form(name) {\n    return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n  } // booleans and numbers\n\n\n  function primitive(pattern) {\n    return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n  } // Patterns in regular expressions\n  // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n  // & and : are excluded as they are usually used for special purposes\n\n\n  var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+'; // symbol starting with & used in function arguments\n\n  var marker = '&' + symbol; // Open parenthesis for look-behind\n\n  var par = '(\\\\()';\n  var endpar = '(?=\\\\))'; // End the pattern with look-ahead space\n\n  var space = '(?=\\\\s)';\n  var language = {\n    // Three or four semicolons are considered a heading.\n    // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n    heading: {\n      pattern: /;;;.*/,\n      alias: ['comment', 'title']\n    },\n    comment: /;.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      greedy: true,\n      inside: {\n        argument: /[-A-Z]+(?=[.,\\s])/,\n        symbol: RegExp('`' + symbol + \"'\")\n      }\n    },\n    'quoted-symbol': {\n      pattern: RegExp(\"#?'\" + symbol),\n      alias: ['variable', 'symbol']\n    },\n    'lisp-property': {\n      pattern: RegExp(':' + symbol),\n      alias: 'property'\n    },\n    splice: {\n      pattern: RegExp(',@?' + symbol),\n      alias: ['symbol', 'variable']\n    },\n    keyword: [{\n      pattern: RegExp(par + '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' + space),\n      lookbehind: true\n    }, {\n      pattern: RegExp(par + '(?:for|do|collect|return|finally|append|concat|in|by)' + space),\n      lookbehind: true\n    }],\n    declare: {\n      pattern: simple_form('declare'),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    interactive: {\n      pattern: simple_form('interactive'),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    boolean: {\n      pattern: primitive('(?:t|nil)'),\n      lookbehind: true\n    },\n    number: {\n      pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n      lookbehind: true\n    },\n    defvar: {\n      pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n      lookbehind: true,\n      inside: {\n        keyword: /^def[a-z]+/,\n        variable: RegExp(symbol)\n      }\n    },\n    defun: {\n      pattern: RegExp(par + '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' + symbol + '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'),\n      lookbehind: true,\n      inside: {\n        keyword: /^(?:cl-)?def\\S+/,\n        // See below, this property needs to be defined later so that it can\n        // reference the language object.\n        arguments: null,\n        function: {\n          pattern: RegExp('(^\\\\s)' + symbol),\n          lookbehind: true\n        },\n        punctuation: /[()]/\n      }\n    },\n    lambda: {\n      pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n      lookbehind: true,\n      inside: {\n        keyword: /^lambda/,\n        // See below, this property needs to be defined later so that it can\n        // reference the language object.\n        arguments: null,\n        punctuation: /[()]/\n      }\n    },\n    car: {\n      pattern: RegExp(par + symbol),\n      lookbehind: true\n    },\n    punctuation: [// open paren, brackets, and close paren\n    /(?:['`,]?\\(|[)\\[\\]])/, // cons\n    {\n      pattern: /(\\s)\\.(?=\\s)/,\n      lookbehind: true\n    }]\n  };\n  var arg = {\n    'lisp-marker': RegExp(marker),\n    rest: {\n      argument: {\n        pattern: RegExp(symbol),\n        alias: 'variable'\n      },\n      varform: {\n        pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n        lookbehind: true,\n        inside: {\n          string: language.string,\n          boolean: language.boolean,\n          number: language.number,\n          symbol: language.symbol,\n          punctuation: /[()]/\n        }\n      }\n    }\n  };\n  var forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n  var arglist = {\n    pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n    lookbehind: true,\n    inside: {\n      'rest-vars': {\n        pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n        inside: arg\n      },\n      'other-marker-vars': {\n        pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n        inside: arg\n      },\n      keys: {\n        pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n        inside: arg\n      },\n      argument: {\n        pattern: RegExp(symbol),\n        alias: 'variable'\n      },\n      punctuation: /[()]/\n    }\n  };\n  language['lambda'].inside.arguments = arglist;\n  language['defun'].inside.arguments = Prism.util.clone(arglist);\n  language['defun'].inside.arguments.inside.sublist = arglist;\n  Prism.languages.lisp = language;\n  Prism.languages.elisp = language;\n  Prism.languages.emacs = language;\n  Prism.languages['emacs-lisp'] = language;\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/User/Desktop/jbook/node_modules/prismjs/components/prism-lisp.js"],"names":["Prism","simple_form","name","RegExp","primitive","pattern","symbol","marker","par","endpar","space","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","rest","varform","forms","arglist","keys","util","clone","sublist","languages","lisp","elisp","emacs"],"mappings":";;;;;AAAC,WAAUA,KAAV,EAAiB;AACjB;AACA;AACA;AACA,WAASC,WAAT,CAAqBC,IAArB,EAA2B;AAC1B,WAAOC,MAAM,CAAC,UAAUD,IAAV,GAAiB,cAAlB,CAAb;AACA,GANgB,CAOjB;;;AACA,WAASE,SAAT,CAAmBC,OAAnB,EAA4B;AAC3B,WAAOF,MAAM,CAAC,cAAcE,OAAd,GAAwB,YAAzB,CAAb;AACA,GAVgB,CAYjB;AAEA;AACA;;;AACA,MAAIC,MAAM,GAAG,wBAAb,CAhBiB,CAiBjB;;AACA,MAAIC,MAAM,GAAG,MAAMD,MAAnB,CAlBiB,CAmBjB;;AACA,MAAIE,GAAG,GAAG,OAAV;AACA,MAAIC,MAAM,GAAG,SAAb,CArBiB,CAsBjB;;AACA,MAAIC,KAAK,GAAG,SAAZ;AAEA,MAAIC,QAAQ,GAAG;AACd;AACA;AACAC,WAAO,EAAE;AACRP,aAAO,EAAE,OADD;AAERQ,WAAK,EAAE,CAAC,SAAD,EAAY,OAAZ;AAFC,KAHK;AAOdC,WAAO,EAAE,KAPK;AAQdC,UAAM,EAAE;AACPV,aAAO,EAAE,mBADF;AAEPW,YAAM,EAAE,IAFD;AAGPC,YAAM,EAAE;AACPC,gBAAQ,EAAE,mBADH;AAEPZ,cAAM,EAAEH,MAAM,CAAC,MAAMG,MAAN,GAAe,GAAhB;AAFP;AAHD,KARM;AAgBd,qBAAiB;AAChBD,aAAO,EAAEF,MAAM,CAAC,QAAQG,MAAT,CADC;AAEhBO,WAAK,EAAE,CAAC,UAAD,EAAa,QAAb;AAFS,KAhBH;AAoBd,qBAAiB;AAChBR,aAAO,EAAEF,MAAM,CAAC,MAAMG,MAAP,CADC;AAEhBO,WAAK,EAAE;AAFS,KApBH;AAwBdM,UAAM,EAAE;AACPd,aAAO,EAAEF,MAAM,CAAC,QAAQG,MAAT,CADR;AAEPO,WAAK,EAAE,CAAC,QAAD,EAAW,UAAX;AAFA,KAxBM;AA4BdO,WAAO,EAAE,CACR;AACCf,aAAO,EAAEF,MAAM,CACdK,GAAG,GACF,6IADD,GAECE,KAHa,CADhB;AAMCW,gBAAU,EAAE;AANb,KADQ,EASR;AACChB,aAAO,EAAEF,MAAM,CACdK,GAAG,GAAG,uDAAN,GAAgEE,KADlD,CADhB;AAICW,gBAAU,EAAE;AAJb,KATQ,CA5BK;AA4CdC,WAAO,EAAE;AACRjB,aAAO,EAAEJ,WAAW,CAAC,SAAD,CADZ;AAERoB,gBAAU,EAAE,IAFJ;AAGRR,WAAK,EAAE;AAHC,KA5CK;AAiDdU,eAAW,EAAE;AACZlB,aAAO,EAAEJ,WAAW,CAAC,aAAD,CADR;AAEZoB,gBAAU,EAAE,IAFA;AAGZR,WAAK,EAAE;AAHK,KAjDC;AAsDdW,WAAO,EAAE;AACRnB,aAAO,EAAED,SAAS,CAAC,WAAD,CADV;AAERiB,gBAAU,EAAE;AAFJ,KAtDK;AA0DdI,UAAM,EAAE;AACPpB,aAAO,EAAED,SAAS,CAAC,uBAAD,CADX;AAEPiB,gBAAU,EAAE;AAFL,KA1DM;AA8DdK,UAAM,EAAE;AACPrB,aAAO,EAAEF,MAAM,CAACK,GAAG,GAAG,mCAAN,GAA4CF,MAA7C,CADR;AAEPe,gBAAU,EAAE,IAFL;AAGPJ,YAAM,EAAE;AACPG,eAAO,EAAE,YADF;AAEPO,gBAAQ,EAAExB,MAAM,CAACG,MAAD;AAFT;AAHD,KA9DM;AAsEdsB,SAAK,EAAE;AACNvB,aAAO,EAAEF,MAAM,CACdK,GAAG,GACF,oCADD,GAECF,MAFD,GAGC,sBAJa,CADT;AAONe,gBAAU,EAAE,IAPN;AAQNJ,YAAM,EAAE;AACPG,eAAO,EAAE,iBADF;AAEP;AACA;AACAS,iBAAS,EAAE,IAJJ;AAKPC,gBAAQ,EAAE;AACTzB,iBAAO,EAAEF,MAAM,CAAC,WAAWG,MAAZ,CADN;AAETe,oBAAU,EAAE;AAFH,SALH;AASPU,mBAAW,EAAE;AATN;AARF,KAtEO;AA0FdC,UAAM,EAAE;AACP3B,aAAO,EAAEF,MAAM,CAACK,GAAG,GAAG,oBAAN,GAA6BF,MAA7B,GAAsC,WAAvC,CADR;AAEPe,gBAAU,EAAE,IAFL;AAGPJ,YAAM,EAAE;AACPG,eAAO,EAAE,SADF;AAEP;AACA;AACAS,iBAAS,EAAE,IAJJ;AAKPE,mBAAW,EAAE;AALN;AAHD,KA1FM;AAqGdE,OAAG,EAAE;AACJ5B,aAAO,EAAEF,MAAM,CAACK,GAAG,GAAGF,MAAP,CADX;AAEJe,gBAAU,EAAE;AAFR,KArGS;AAyGdU,eAAW,EAAE,CACZ;AACA,0BAFY,EAGZ;AACA;AACC1B,aAAO,EAAE,cADV;AAECgB,gBAAU,EAAE;AAFb,KAJY;AAzGC,GAAf;AAoHA,MAAIa,GAAG,GAAG;AACT,mBAAe/B,MAAM,CAACI,MAAD,CADZ;AAET4B,QAAI,EAAE;AACLjB,cAAQ,EAAE;AACTb,eAAO,EAAEF,MAAM,CAACG,MAAD,CADN;AAETO,aAAK,EAAE;AAFE,OADL;AAKLuB,aAAO,EAAE;AACR/B,eAAO,EAAEF,MAAM,CAACK,GAAG,GAAGF,MAAN,GAAe,kBAAf,GAAoCG,MAArC,CADP;AAERY,kBAAU,EAAE,IAFJ;AAGRJ,cAAM,EAAE;AACPF,gBAAM,EAAEJ,QAAQ,CAACI,MADV;AAEPS,iBAAO,EAAEb,QAAQ,CAACa,OAFX;AAGPC,gBAAM,EAAEd,QAAQ,CAACc,MAHV;AAIPnB,gBAAM,EAAEK,QAAQ,CAACL,MAJV;AAKPyB,qBAAW,EAAE;AALN;AAHA;AALJ;AAFG,GAAV;AAqBA,MAAIM,KAAK,GAAG,mBAAZ;AAEA,MAAIC,OAAO,GAAG;AACbjC,WAAO,EAAEF,MAAM,CAACK,GAAG,GAAG,WAAN,GAAoBC,MAArB,CADF;AAEbY,cAAU,EAAE,IAFC;AAGbJ,UAAM,EAAE;AACP,mBAAa;AACZZ,eAAO,EAAEF,MAAM,CAAC,uBAAuBkC,KAAxB,CADH;AAEZpB,cAAM,EAAEiB;AAFI,OADN;AAKP,2BAAqB;AACpB7B,eAAO,EAAEF,MAAM,CAAC,0BAA0BkC,KAA3B,CADK;AAEpBpB,cAAM,EAAEiB;AAFY,OALd;AASPK,UAAI,EAAE;AACLlC,eAAO,EAAEF,MAAM,CAAC,aAAakC,KAAb,GAAqB,4BAAtB,CADV;AAELpB,cAAM,EAAEiB;AAFH,OATC;AAaPhB,cAAQ,EAAE;AACTb,eAAO,EAAEF,MAAM,CAACG,MAAD,CADN;AAETO,aAAK,EAAE;AAFE,OAbH;AAiBPkB,iBAAW,EAAE;AAjBN;AAHK,GAAd;AAwBApB,UAAQ,CAAC,QAAD,CAAR,CAAmBM,MAAnB,CAA0BY,SAA1B,GAAsCS,OAAtC;AACA3B,UAAQ,CAAC,OAAD,CAAR,CAAkBM,MAAlB,CAAyBY,SAAzB,GAAqC7B,KAAK,CAACwC,IAAN,CAAWC,KAAX,CAAiBH,OAAjB,CAArC;AACA3B,UAAQ,CAAC,OAAD,CAAR,CAAkBM,MAAlB,CAAyBY,SAAzB,CAAmCZ,MAAnC,CAA0CyB,OAA1C,GAAoDJ,OAApD;AAEAtC,OAAK,CAAC2C,SAAN,CAAgBC,IAAhB,GAAuBjC,QAAvB;AACAX,OAAK,CAAC2C,SAAN,CAAgBE,KAAhB,GAAwBlC,QAAxB;AACAX,OAAK,CAAC2C,SAAN,CAAgBG,KAAhB,GAAwBnC,QAAxB;AACAX,OAAK,CAAC2C,SAAN,CAAgB,YAAhB,IAAgChC,QAAhC;AACA,CApMA,EAoMCX,KApMD,CAAD,C","file":"x","sourcesContent":["(function (Prism) {\n\t// Functions to construct regular expressions\n\t// simple form\n\t// e.g. (interactive ... or (interactive)\n\tfunction simple_form(name) {\n\t\treturn RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n\t}\n\t// booleans and numbers\n\tfunction primitive(pattern) {\n\t\treturn RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n\t}\n\n\t// Patterns in regular expressions\n\n\t// Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n\t// & and : are excluded as they are usually used for special purposes\n\tvar symbol = '[-+*/_~!@$%^=<>{}\\\\w]+';\n\t// symbol starting with & used in function arguments\n\tvar marker = '&' + symbol;\n\t// Open parenthesis for look-behind\n\tvar par = '(\\\\()';\n\tvar endpar = '(?=\\\\))';\n\t// End the pattern with look-ahead space\n\tvar space = '(?=\\\\s)';\n\n\tvar language = {\n\t\t// Three or four semicolons are considered a heading.\n\t\t// See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n\t\theading: {\n\t\t\tpattern: /;;;.*/,\n\t\t\talias: ['comment', 'title']\n\t\t},\n\t\tcomment: /;.*/,\n\t\tstring: {\n\t\t\tpattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\targument: /[-A-Z]+(?=[.,\\s])/,\n\t\t\t\tsymbol: RegExp('`' + symbol + \"'\")\n\t\t\t}\n\t\t},\n\t\t'quoted-symbol': {\n\t\t\tpattern: RegExp(\"#?'\" + symbol),\n\t\t\talias: ['variable', 'symbol']\n\t\t},\n\t\t'lisp-property': {\n\t\t\tpattern: RegExp(':' + symbol),\n\t\t\talias: 'property'\n\t\t},\n\t\tsplice: {\n\t\t\tpattern: RegExp(',@?' + symbol),\n\t\t\talias: ['symbol', 'variable']\n\t\t},\n\t\tkeyword: [\n\t\t\t{\n\t\t\t\tpattern: RegExp(\n\t\t\t\t\tpar +\n\t\t\t\t\t\t'(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' +\n\t\t\t\t\t\tspace\n\t\t\t\t),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: RegExp(\n\t\t\t\t\tpar + '(?:for|do|collect|return|finally|append|concat|in|by)' + space\n\t\t\t\t),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t],\n\t\tdeclare: {\n\t\t\tpattern: simple_form('declare'),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\t\tinteractive: {\n\t\t\tpattern: simple_form('interactive'),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\t\tboolean: {\n\t\t\tpattern: primitive('(?:t|nil)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\tnumber: {\n\t\t\tpattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n\t\t\tlookbehind: true\n\t\t},\n\t\tdefvar: {\n\t\t\tpattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^def[a-z]+/,\n\t\t\t\tvariable: RegExp(symbol)\n\t\t\t}\n\t\t},\n\t\tdefun: {\n\t\t\tpattern: RegExp(\n\t\t\t\tpar +\n\t\t\t\t\t'(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' +\n\t\t\t\t\tsymbol +\n\t\t\t\t\t'\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^(?:cl-)?def\\S+/,\n\t\t\t\t// See below, this property needs to be defined later so that it can\n\t\t\t\t// reference the language object.\n\t\t\t\targuments: null,\n\t\t\t\tfunction: {\n\t\t\t\t\tpattern: RegExp('(^\\\\s)' + symbol),\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\tpunctuation: /[()]/\n\t\t\t}\n\t\t},\n\t\tlambda: {\n\t\t\tpattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^lambda/,\n\t\t\t\t// See below, this property needs to be defined later so that it can\n\t\t\t\t// reference the language object.\n\t\t\t\targuments: null,\n\t\t\t\tpunctuation: /[()]/\n\t\t\t}\n\t\t},\n\t\tcar: {\n\t\t\tpattern: RegExp(par + symbol),\n\t\t\tlookbehind: true\n\t\t},\n\t\tpunctuation: [\n\t\t\t// open paren, brackets, and close paren\n\t\t\t/(?:['`,]?\\(|[)\\[\\]])/,\n\t\t\t// cons\n\t\t\t{\n\t\t\t\tpattern: /(\\s)\\.(?=\\s)/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t]\n\t};\n\n\tvar arg = {\n\t\t'lisp-marker': RegExp(marker),\n\t\trest: {\n\t\t\targument: {\n\t\t\t\tpattern: RegExp(symbol),\n\t\t\t\talias: 'variable'\n\t\t\t},\n\t\t\tvarform: {\n\t\t\t\tpattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\tstring: language.string,\n\t\t\t\t\tboolean: language.boolean,\n\t\t\t\t\tnumber: language.number,\n\t\t\t\t\tsymbol: language.symbol,\n\t\t\t\t\tpunctuation: /[()]/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n\n\tvar arglist = {\n\t\tpattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'rest-vars': {\n\t\t\t\tpattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\t'other-marker-vars': {\n\t\t\t\tpattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tpattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\targument: {\n\t\t\t\tpattern: RegExp(symbol),\n\t\t\t\talias: 'variable'\n\t\t\t},\n\t\t\tpunctuation: /[()]/\n\t\t}\n\t};\n\n\tlanguage['lambda'].inside.arguments = arglist;\n\tlanguage['defun'].inside.arguments = Prism.util.clone(arglist);\n\tlanguage['defun'].inside.arguments.inside.sublist = arglist;\n\n\tPrism.languages.lisp = language;\n\tPrism.languages.elisp = language;\n\tPrism.languages.emacs = language;\n\tPrism.languages['emacs-lisp'] = language;\n}(Prism));\n"]}}