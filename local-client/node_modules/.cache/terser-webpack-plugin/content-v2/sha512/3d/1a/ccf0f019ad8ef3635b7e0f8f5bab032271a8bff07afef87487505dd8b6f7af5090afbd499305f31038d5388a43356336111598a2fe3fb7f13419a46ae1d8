{"code":"(this.webpackJsonpjbook=this.webpackJsonpjbook||[]).push([[460],{628:function(e,t){!function(e){e.languages.xquery=e.languages.extend(\"markup\",{\"xquery-comment\":{pattern:/\\(:[\\s\\S]*?:\\)/,greedy:!0,alias:\"comment\"},string:{pattern:/([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,greedy:!0},extension:{pattern:/\\(#.+?#\\)/,alias:\"symbol\"},variable:/\\$[\\w-:]+/,axis:{pattern:/(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,lookbehind:!0,alias:\"operator\"},\"keyword-operator\":{pattern:/(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,lookbehind:!0,alias:\"operator\"},keyword:{pattern:/(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,lookbehind:!0},function:/[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\"xquery-element\":{pattern:/(element\\s+)[\\w-]+(?::[\\w-]+)*/,lookbehind:!0,alias:\"tag\"},\"xquery-attribute\":{pattern:/(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,lookbehind:!0,alias:\"attr-name\"},builtin:{pattern:/(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,lookbehind:!0},number:/\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,operator:[/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,{pattern:/(\\s)-(?=\\s)/,lookbehind:!0}],punctuation:/[[\\](){},;:/]/}),e.languages.xquery.tag.pattern=/<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,e.languages.xquery.tag.inside[\"attr-value\"].pattern=/=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i,e.languages.xquery.tag.inside[\"attr-value\"].inside.punctuation=/^=\"|\"$/,e.languages.xquery.tag.inside[\"attr-value\"].inside.expression={pattern:/{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}/,inside:e.languages.xquery,alias:\"language-xquery\"};var t=function e(t){return\"string\"===typeof t?t:\"string\"===typeof t.content?t.content:t.content.map(e).join(\"\")},n=function n(a){for(var o=[],i=0;i<a.length;i++){var r=a[i],s=!1;if(\"string\"!==typeof r&&(\"tag\"===r.type&&r.content[0]&&\"tag\"===r.content[0].type?\"</\"===r.content[0].content[0].content?o.length>0&&o[o.length-1].tagName===t(r.content[0].content[1])&&o.pop():\"/>\"===r.content[r.content.length-1].content||o.push({tagName:t(r.content[0].content[1]),openedBraces:0}):!(o.length>0&&\"punctuation\"===r.type&&\"{\"===r.content)||a[i+1]&&\"punctuation\"===a[i+1].type&&\"{\"===a[i+1].content||a[i-1]&&\"plain-text\"===a[i-1].type&&\"{\"===a[i-1].content?o.length>0&&o[o.length-1].openedBraces>0&&\"punctuation\"===r.type&&\"}\"===r.content?o[o.length-1].openedBraces--:\"comment\"!==r.type&&(s=!0):o[o.length-1].openedBraces++),(s||\"string\"===typeof r)&&o.length>0&&0===o[o.length-1].openedBraces){var l=t(r);i<a.length-1&&(\"string\"===typeof a[i+1]||\"plain-text\"===a[i+1].type)&&(l+=t(a[i+1]),a.splice(i+1,1)),i>0&&(\"string\"===typeof a[i-1]||\"plain-text\"===a[i-1].type)&&(l=t(a[i-1])+l,a.splice(i-1,1),i--),/^\\s+$/.test(l)?a[i]=l:a[i]=new e.Token(\"plain-text\",l,null,l)}r.content&&\"string\"!==typeof r.content&&n(r.content)}};e.hooks.add(\"after-tokenize\",(function(e){\"xquery\"===e.language&&n(e.tokens)}))}(Prism)}}]);","name":"static/js/460.31989d4c.chunk.js","map":{"version":3,"sources":["static/js/460.31989d4c.chunk.js"],"names":["this","push","628","module","exports","Prism","languages","xquery","extend","xquery-comment","pattern","greedy","alias","string","extension","variable","axis","lookbehind","keyword-operator","keyword","function","xquery-element","xquery-attribute","builtin","number","operator","punctuation","tag","inside","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","openedBraces","plainText","splice","test","Token","hooks","add","env","language"],"mappings":"CAACA,KAAwB,kBAAIA,KAAwB,mBAAK,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEpEC,IACA,SAAUC,EAAQC,IAExB,SAAWC,GACTA,EAAMC,UAAUC,OAASF,EAAMC,UAAUE,OAAO,SAAU,CACxDC,iBAAkB,CAChBC,QAAS,iBACTC,QAAQ,EACRC,MAAO,WAETC,OAAU,CACRH,QAAS,iCACTC,QAAQ,GAEVG,UAAa,CACXJ,QAAS,YACTE,MAAO,UAETG,SAAY,YACZC,KAAQ,CACNN,QAAS,4IACTO,YAAY,EACZL,MAAO,YAETM,mBAAoB,CAClBR,QAAS,sHACTO,YAAY,EACZL,MAAO,YAETO,QAAW,CACTT,QAAS,ocACTO,YAAY,GAEdG,SAAY,8BACZC,iBAAkB,CAChBX,QAAS,iCACTO,YAAY,EACZL,MAAO,OAETU,mBAAoB,CAClBZ,QAAS,mCACTO,YAAY,EACZL,MAAO,aAETW,QAAW,CACTb,QAAS,shBACTO,YAAY,GAEdO,OAAU,gCACVC,SAAY,CAAC,qCAAsC,CACjDf,QAAS,cACTO,YAAY,IAEdS,YAAe,kBAEjBrB,EAAMC,UAAUC,OAAOoB,IAAIjB,QAAU,iJACrCL,EAAMC,UAAUC,OAAY,IAAEqB,OAAO,cAAclB,QAAU,4FAC7DL,EAAMC,UAAUC,OAAY,IAAEqB,OAAO,cAAcA,OAAoB,YAAI,SAC3EvB,EAAMC,UAAUC,OAAY,IAAEqB,OAAO,cAAcA,OAAmB,WAAI,CAExElB,QAAS,0CACTkB,OAAQvB,EAAMC,UAAUC,OACxBK,MAAO,mBAGT,IAAIiB,EAAiB,SAASA,EAAeC,GAC3C,MAAqB,kBAAVA,EACFA,EAGoB,kBAAlBA,EAAMC,QACRD,EAAMC,QAGRD,EAAMC,QAAQC,IAAIH,GAAgBI,KAAK,KAG5CC,EAAa,SAASA,EAAWC,GAGnC,IAFA,IAAIC,EAAa,GAERC,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAAK,CACtC,IAAIP,EAAQK,EAAOE,GACfE,GAAiB,EAiCrB,GA/BqB,kBAAVT,IACU,QAAfA,EAAMU,MAAkBV,EAAMC,QAAQ,IAAgC,QAA1BD,EAAMC,QAAQ,GAAGS,KAEnB,OAAxCV,EAAMC,QAAQ,GAAGA,QAAQ,GAAGA,QAE1BK,EAAWE,OAAS,GAAKF,EAAWA,EAAWE,OAAS,GAAGG,UAAYZ,EAAeC,EAAMC,QAAQ,GAAGA,QAAQ,KAEjHK,EAAWM,MAG2C,OAApDZ,EAAMC,QAAQD,EAAMC,QAAQO,OAAS,GAAGP,SAG1CK,EAAWnC,KAAK,CACdwC,QAASZ,EAAeC,EAAMC,QAAQ,GAAGA,QAAQ,IACjDY,aAAc,MAIXP,EAAWE,OAAS,GAAoB,gBAAfR,EAAMU,MAA4C,MAAlBV,EAAMC,UACzEI,EAAOE,EAAI,IAA6B,gBAAvBF,EAAOE,EAAI,GAAGG,MAAoD,MAA1BL,EAAOE,EAAI,GAAGN,SAAsBI,EAAOE,EAAI,IAA6B,eAAvBF,EAAOE,EAAI,GAAGG,MAAmD,MAA1BL,EAAOE,EAAI,GAAGN,QAGzJK,EAAWE,OAAS,GAAKF,EAAWA,EAAWE,OAAS,GAAGK,aAAe,GAAoB,gBAAfb,EAAMU,MAA4C,MAAlBV,EAAMC,QAE9HK,EAAWA,EAAWE,OAAS,GAAGK,eACV,YAAfb,EAAMU,OACfD,GAAiB,GALjBH,EAAWA,EAAWE,OAAS,GAAGK,iBASlCJ,GAAmC,kBAAVT,IACvBM,EAAWE,OAAS,GAAwD,IAAnDF,EAAWA,EAAWE,OAAS,GAAGK,aAAoB,CAGjF,IAAIC,EAAYf,EAAeC,GAE3BO,EAAIF,EAAOG,OAAS,IAA+B,kBAAlBH,EAAOE,EAAI,IAA0C,eAAvBF,EAAOE,EAAI,GAAGG,QAC/EI,GAAaf,EAAeM,EAAOE,EAAI,IACvCF,EAAOU,OAAOR,EAAI,EAAG,IAGnBA,EAAI,IAA+B,kBAAlBF,EAAOE,EAAI,IAA0C,eAAvBF,EAAOE,EAAI,GAAGG,QAC/DI,EAAYf,EAAeM,EAAOE,EAAI,IAAMO,EAC5CT,EAAOU,OAAOR,EAAI,EAAG,GACrBA,KAGE,QAAQS,KAAKF,GACfT,EAAOE,GAAKO,EAEZT,EAAOE,GAAK,IAAIhC,EAAM0C,MAAM,aAAcH,EAAW,KAAMA,GAK7Dd,EAAMC,SAAoC,kBAAlBD,EAAMC,SAChCG,EAAWJ,EAAMC,WAKvB1B,EAAM2C,MAAMC,IAAI,kBAAkB,SAAUC,GACrB,WAAjBA,EAAIC,UAIRjB,EAAWgB,EAAIf,WApJnB,CAsJG9B"},"input":"(this[\"webpackJsonpjbook\"] = this[\"webpackJsonpjbook\"] || []).push([[460],{\n\n/***/ 628:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  Prism.languages.xquery = Prism.languages.extend('markup', {\n    'xquery-comment': {\n      pattern: /\\(:[\\s\\S]*?:\\)/,\n      greedy: true,\n      alias: \"comment\"\n    },\n    'string': {\n      pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n      greedy: true\n    },\n    'extension': {\n      pattern: /\\(#.+?#\\)/,\n      alias: 'symbol'\n    },\n    'variable': /\\$[\\w-:]+/,\n    'axis': {\n      pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n      lookbehind: true,\n      alias: 'operator'\n    },\n    'keyword-operator': {\n      pattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n      lookbehind: true,\n      alias: 'operator'\n    },\n    'keyword': {\n      pattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n      lookbehind: true\n    },\n    'function': /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n    'xquery-element': {\n      pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n      lookbehind: true,\n      alias: 'tag'\n    },\n    'xquery-attribute': {\n      pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n      lookbehind: true,\n      alias: 'attr-name'\n    },\n    'builtin': {\n      pattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n      lookbehind: true\n    },\n    'number': /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n    'operator': [/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/, {\n      pattern: /(\\s)-(?=\\s)/,\n      lookbehind: true\n    }],\n    'punctuation': /[[\\](){},;:/]/\n  });\n  Prism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i;\n  Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i;\n  Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\n  Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n    // Allow for two levels of nesting\n    pattern: /{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}/,\n    inside: Prism.languages.xquery,\n    alias: 'language-xquery'\n  }; // The following will handle plain text inside tags\n\n  var stringifyToken = function stringifyToken(token) {\n    if (typeof token === 'string') {\n      return token;\n    }\n\n    if (typeof token.content === 'string') {\n      return token.content;\n    }\n\n    return token.content.map(stringifyToken).join('');\n  };\n\n  var walkTokens = function walkTokens(tokens) {\n    var openedTags = [];\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      var notTagNorBrace = false;\n\n      if (typeof token !== 'string') {\n        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n          // We found a tag, now find its kind\n          if (token.content[0].content[0].content === '</') {\n            // Closing tag\n            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n              // Pop matching opening tag\n              openedTags.pop();\n            }\n          } else {\n            if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n            } else {\n              // Opening tag\n              openedTags.push({\n                tagName: stringifyToken(token.content[0].content[1]),\n                openedBraces: 0\n              });\n            }\n          }\n        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' && ( // Ignore `{{`\n        !tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') && (!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')) {\n          // Here we might have entered an XQuery expression inside a tag\n          openedTags[openedTags.length - 1].openedBraces++;\n        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n          // Here we might have left an XQuery expression inside a tag\n          openedTags[openedTags.length - 1].openedBraces--;\n        } else if (token.type !== 'comment') {\n          notTagNorBrace = true;\n        }\n      }\n\n      if (notTagNorBrace || typeof token === 'string') {\n        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n          // Here we are inside a tag, and not inside an XQuery expression.\n          // That's plain text: drop any tokens matched.\n          var plainText = stringifyToken(token); // And merge text with adjacent text\n\n          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n            plainText += stringifyToken(tokens[i + 1]);\n            tokens.splice(i + 1, 1);\n          }\n\n          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n            plainText = stringifyToken(tokens[i - 1]) + plainText;\n            tokens.splice(i - 1, 1);\n            i--;\n          }\n\n          if (/^\\s+$/.test(plainText)) {\n            tokens[i] = plainText;\n          } else {\n            tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n          }\n        }\n      }\n\n      if (token.content && typeof token.content !== 'string') {\n        walkTokens(token.content);\n      }\n    }\n  };\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'xquery') {\n      return;\n    }\n\n    walkTokens(env.tokens);\n  });\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/User/Desktop/jbook/node_modules/prismjs/components/prism-xquery.js"],"names":["Prism","languages","xquery","extend","pattern","greedy","alias","lookbehind","tag","inside","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","test","Token","hooks","add","env","language"],"mappings":"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","file":"x","sourcesContent":["(function (Prism) {\n\n\tPrism.languages.xquery = Prism.languages.extend('markup', {\n\t\t'xquery-comment': {\n\t\t\tpattern: /\\(:[\\s\\S]*?:\\)/,\n\t\t\tgreedy: true,\n\t\t\talias: \"comment\"\n\t\t},\n\t\t'string': {\n\t\t\tpattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'extension': {\n\t\t\tpattern: /\\(#.+?#\\)/,\n\t\t\talias: 'symbol'\n\t\t},\n\t\t'variable': /\\$[\\w-:]+/,\n\t\t'axis': {\n\t\t\tpattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'operator'\n\t\t},\n\t\t'keyword-operator': {\n\t\t\tpattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'operator'\n\t\t},\n\t\t'keyword': {\n\t\t\tpattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'function': /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n\t\t'xquery-element': {\n\t\t\tpattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'tag'\n\t\t},\n\t\t'xquery-attribute': {\n\t\t\tpattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'attr-name'\n\t\t},\n\t\t'builtin': {\n\t\t\tpattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'number': /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n\t\t'operator': [\n\t\t\t/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\n\t\t\t{\n\t\t\t\tpattern: /(\\s)-(?=\\s)/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'punctuation': /[[\\](){},;:/]/\n\t});\n\n\tPrism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i;\n\tPrism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i;\n\tPrism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\n\tPrism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n\t\t// Allow for two levels of nesting\n\t\tpattern: /{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}/,\n\t\tinside: Prism.languages.xquery,\n\t\talias: 'language-xquery'\n\t};\n\n\t// The following will handle plain text inside tags\n\tvar stringifyToken = function (token) {\n\t\tif (typeof token === 'string') {\n\t\t\treturn token;\n\t\t}\n\t\tif (typeof token.content === 'string') {\n\t\t\treturn token.content;\n\t\t}\n\t\treturn token.content.map(stringifyToken).join('');\n\t};\n\n\tvar walkTokens = function (tokens) {\n\t\tvar openedTags = [];\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tvar notTagNorBrace = false;\n\n\t\t\tif (typeof token !== 'string') {\n\t\t\t\tif (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n\t\t\t\t\t// We found a tag, now find its kind\n\n\t\t\t\t\tif (token.content[0].content[0].content === '</') {\n\t\t\t\t\t\t// Closing tag\n\t\t\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n\t\t\t\t\t\t\t// Pop matching opening tag\n\t\t\t\t\t\t\topenedTags.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (token.content[token.content.length - 1].content === '/>') {\n\t\t\t\t\t\t\t// Autoclosed tag, ignore\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Opening tag\n\t\t\t\t\t\t\topenedTags.push({\n\t\t\t\t\t\t\t\ttagName: stringifyToken(token.content[0].content[1]),\n\t\t\t\t\t\t\t\topenedBraces: 0\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\topenedTags.length > 0 && token.type === 'punctuation' && token.content === '{' &&\n\t\t\t\t\t// Ignore `{{`\n\t\t\t\t\t(!tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') &&\n\t\t\t\t\t(!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')\n\t\t\t\t) {\n\t\t\t\t\t// Here we might have entered an XQuery expression inside a tag\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces++;\n\n\t\t\t\t} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n\n\t\t\t\t\t// Here we might have left an XQuery expression inside a tag\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces--;\n\n\t\t\t\t} else if (token.type !== 'comment') {\n\t\t\t\t\tnotTagNorBrace = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (notTagNorBrace || typeof token === 'string') {\n\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n\t\t\t\t\t// Here we are inside a tag, and not inside an XQuery expression.\n\t\t\t\t\t// That's plain text: drop any tokens matched.\n\t\t\t\t\tvar plainText = stringifyToken(token);\n\n\t\t\t\t\t// And merge text with adjacent text\n\t\t\t\t\tif (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n\t\t\t\t\t\tplainText += stringifyToken(tokens[i + 1]);\n\t\t\t\t\t\ttokens.splice(i + 1, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n\t\t\t\t\t\tplainText = stringifyToken(tokens[i - 1]) + plainText;\n\t\t\t\t\t\ttokens.splice(i - 1, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (/^\\s+$/.test(plainText)) {\n\t\t\t\t\t\ttokens[i] = plainText;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (token.content && typeof token.content !== 'string') {\n\t\t\t\twalkTokens(token.content);\n\t\t\t}\n\t\t}\n\t};\n\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (env.language !== 'xquery') {\n\t\t\treturn;\n\t\t}\n\t\twalkTokens(env.tokens);\n\t});\n\n}(Prism));\n"]}}