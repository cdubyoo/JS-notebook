{"code":"(this.webpackJsonpjbook=this.webpackJsonpjbook||[]).push([[346],{514:function(e,a){Prism.languages.racket=Prism.languages.extend(\"scheme\",{\"lambda-parameter\":{pattern:/(\\(lambda\\s+\\()[^()'\\s]+/,lookbehind:!0}}),Prism.languages.DFS(Prism.languages.racket,(function(e,a){if(\"RegExp\"===Prism.util.type(a)){var r=a.source.replace(/\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g,(function(e,a,r){if(a){if(\"(\"===a)return\"[([]\";if(\")\"===a)return\"[)\\\\]]\"}return r?(\"^\"===e[1]?\"[^\":\"[\")+r.replace(/\\\\(.)|[()]/g,(function(e,a){return\"(\"===e||\"(\"===a?\"([\":\")\"===e||\")\"===a?\")\\\\]\":e}))+\"]\":e}));this[e]=RegExp(r,a.flags)}})),Prism.languages.insertBefore(\"racket\",\"string\",{lang:{pattern:/^#lang.+/m,greedy:!0,alias:\"keyword\"}}),Prism.languages.rkt=Prism.languages.racket}}]);","name":"static/js/346.12725ba1.chunk.js","map":{"version":3,"sources":["static/js/346.12725ba1.chunk.js"],"names":["this","push","514","module","exports","Prism","languages","racket","extend","lambda-parameter","pattern","lookbehind","DFS","key","value","util","type","source","replace","m","g1","g2","RegExp","flags","insertBefore","lang","greedy","alias","rkt"],"mappings":"CAACA,KAAwB,kBAAIA,KAAwB,mBAAK,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEpEC,IACA,SAAUC,EAAQC,GAExBC,MAAMC,UAAUC,OAASF,MAAMC,UAAUE,OAAO,SAAU,CACxDC,mBAAoB,CAGlBC,QAAS,2BACTC,YAAY,KAgBhBN,MAAMC,UAAUM,IAAIP,MAAMC,UAAUC,QAAQ,SAAUM,EAAKC,GACzD,GAA+B,WAA3BT,MAAMU,KAAKC,KAAKF,GAAqB,CACvC,IAAIG,EAASH,EAAMG,OAAOC,QAAQ,oCAAoC,SAAUC,EAAGC,EAAIC,GACrF,GAAID,EAAI,CACN,GAAW,MAAPA,EAEF,MAAO,OAGT,GAAW,MAAPA,EAEF,MAAO,SAIX,OAAIC,GACoB,MAATF,EAAE,GAAa,KAAO,KACnBE,EAAGH,QAAQ,eAAe,SAAUC,EAAGC,GACrD,MAAU,MAAND,GAAoB,MAAPC,EAER,KAGC,MAAND,GAAoB,MAAPC,EAER,OAGFD,KACJ,IAGAA,KAETnB,KAAKa,GAAOS,OAAOL,EAAQH,EAAMS,WAGrClB,MAAMC,UAAUkB,aAAa,SAAU,SAAU,CAC/CC,KAAQ,CACNf,QAAS,YACTgB,QAAQ,EACRC,MAAO,aAGXtB,MAAMC,UAAUsB,IAAMvB,MAAMC,UAAUC"},"input":"(this[\"webpackJsonpjbook\"] = this[\"webpackJsonpjbook\"] || []).push([[346],{\n\n/***/ 514:\n/***/ (function(module, exports) {\n\nPrism.languages.racket = Prism.languages.extend('scheme', {\n  'lambda-parameter': {\n    // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.\n    // this will just prevent false positives of the `function` pattern\n    pattern: /(\\(lambda\\s+\\()[^()'\\s]+/,\n    lookbehind: true\n  }\n}); // Add brackets to racket\n// The basic idea here is to go through all pattens of Scheme and replace all occurrences of \"(\" with the union of \"(\"\n// and \"[\"; Similar for \")\". This is a bit tricky because \"(\" can be escaped or inside a character set. Both cases\n// have to be handled differently and, of course, we don't want to destroy groups, so we can only replace literal \"(\"\n// and \")\".\n// To do this, we use a regular expression which will parse any JS regular expression. It works because regexes are\n// matches from left to right and already matched text cannot be matched again. We use this to first capture all\n// escaped characters (not really, we don't get escape sequences but we don't need them). Because we already captured\n// all escaped characters, we know that any \"[\" character is the start of a character set, so we match that character\n// set whole.\n// With the regex parsed, we only have to replace all escaped \"(\" (they cannot be unescaped outside of character sets)\n// with /[([]/ and replace all \"(\" inside character sets.\n// Note: This method does not work for \"(\" that are escaped like this /\\x28/ or this /\\u0028/.\n\nPrism.languages.DFS(Prism.languages.racket, function (key, value) {\n  if (Prism.util.type(value) === 'RegExp') {\n    var source = value.source.replace(/\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g, function (m, g1, g2) {\n      if (g1) {\n        if (g1 === '(') {\n          // replace all '(' characters outside character sets\n          return '[([]';\n        }\n\n        if (g1 === ')') {\n          // replace all ')' characters outside character sets\n          return '[)\\\\]]';\n        }\n      }\n\n      if (g2) {\n        var prefix = m[1] === '^' ? '[^' : '[';\n        return prefix + g2.replace(/\\\\(.)|[()]/g, function (m, g1) {\n          if (m === '(' || g1 === '(') {\n            // replace all '(' characters inside character sets\n            return '([';\n          }\n\n          if (m === ')' || g1 === ')') {\n            // replace all ')' characters inside character sets\n            return ')\\\\]';\n          }\n\n          return m;\n        }) + ']';\n      }\n\n      return m;\n    });\n    this[key] = RegExp(source, value.flags);\n  }\n});\nPrism.languages.insertBefore('racket', 'string', {\n  'lang': {\n    pattern: /^#lang.+/m,\n    greedy: true,\n    alias: 'keyword'\n  }\n});\nPrism.languages.rkt = Prism.languages.racket;\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/User/Desktop/jbook/node_modules/prismjs/components/prism-racket.js"],"names":["Prism","languages","racket","extend","pattern","lookbehind","DFS","key","value","util","type","source","replace","m","g1","g2","prefix","RegExp","flags","insertBefore","greedy","alias","rkt"],"mappings":";;;;;AAAAA,KAAK,CAACC,SAAN,CAAgBC,MAAhB,GAAyBF,KAAK,CAACC,SAAN,CAAgBE,MAAhB,CAAuB,QAAvB,EAAiC;AACzD,sBAAoB;AACnB;AACA;AACAC,WAAO,EAAE,0BAHU;AAInBC,cAAU,EAAE;AAJO;AADqC,CAAjC,CAAzB,C,CASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAL,KAAK,CAACC,SAAN,CAAgBK,GAAhB,CAAoBN,KAAK,CAACC,SAAN,CAAgBC,MAApC,EAA4C,UAAUK,GAAV,EAAeC,KAAf,EAAsB;AACjE,MAAIR,KAAK,CAACS,IAAN,CAAWC,IAAX,CAAgBF,KAAhB,MAA2B,QAA/B,EAAyC;AACxC,QAAIG,MAAM,GAAGH,KAAK,CAACG,MAAN,CAAaC,OAAb,CAAqB,kCAArB,EAAyD,UAAUC,CAAV,EAAaC,EAAb,EAAiBC,EAAjB,EAAqB;AAC1F,UAAID,EAAJ,EAAQ;AACP,YAAIA,EAAE,KAAK,GAAX,EAAgB;AACf;AACA,iBAAO,MAAP;AACA;;AACD,YAAIA,EAAE,KAAK,GAAX,EAAgB;AACf;AACA,iBAAO,QAAP;AACA;AACD;;AACD,UAAIC,EAAJ,EAAQ;AACP,YAAIC,MAAM,GAAGH,CAAC,CAAC,CAAD,CAAD,KAAS,GAAT,GAAe,IAAf,GAAsB,GAAnC;AACA,eAAOG,MAAM,GAAGD,EAAE,CAACH,OAAH,CAAW,aAAX,EAA0B,UAAUC,CAAV,EAAaC,EAAb,EAAiB;AAC1D,cAAID,CAAC,KAAK,GAAN,IAAaC,EAAE,KAAK,GAAxB,EAA6B;AAC5B;AACA,mBAAO,IAAP;AACA;;AACD,cAAID,CAAC,KAAK,GAAN,IAAaC,EAAE,KAAK,GAAxB,EAA6B;AAC5B;AACA,mBAAO,MAAP;AACA;;AACD,iBAAOD,CAAP;AACA,SAVe,CAAT,GAUF,GAVL;AAWA;;AACD,aAAOA,CAAP;AACA,KA1BY,CAAb;AA4BA,SAAKN,GAAL,IAAYU,MAAM,CAACN,MAAD,EAASH,KAAK,CAACU,KAAf,CAAlB;AACA;AACD,CAhCD;AAkCAlB,KAAK,CAACC,SAAN,CAAgBkB,YAAhB,CAA6B,QAA7B,EAAuC,QAAvC,EAAiD;AAChD,UAAQ;AACPf,WAAO,EAAE,WADF;AAEPgB,UAAM,EAAE,IAFD;AAGPC,SAAK,EAAE;AAHA;AADwC,CAAjD;AAQArB,KAAK,CAACC,SAAN,CAAgBqB,GAAhB,GAAsBtB,KAAK,CAACC,SAAN,CAAgBC,MAAtC,C","file":"x","sourcesContent":["Prism.languages.racket = Prism.languages.extend('scheme', {\n\t'lambda-parameter': {\n\t\t// the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.\n\t\t// this will just prevent false positives of the `function` pattern\n\t\tpattern: /(\\(lambda\\s+\\()[^()'\\s]+/,\n\t\tlookbehind: true\n\t}\n});\n\n// Add brackets to racket\n// The basic idea here is to go through all pattens of Scheme and replace all occurrences of \"(\" with the union of \"(\"\n// and \"[\"; Similar for \")\". This is a bit tricky because \"(\" can be escaped or inside a character set. Both cases\n// have to be handled differently and, of course, we don't want to destroy groups, so we can only replace literal \"(\"\n// and \")\".\n// To do this, we use a regular expression which will parse any JS regular expression. It works because regexes are\n// matches from left to right and already matched text cannot be matched again. We use this to first capture all\n// escaped characters (not really, we don't get escape sequences but we don't need them). Because we already captured\n// all escaped characters, we know that any \"[\" character is the start of a character set, so we match that character\n// set whole.\n// With the regex parsed, we only have to replace all escaped \"(\" (they cannot be unescaped outside of character sets)\n// with /[([]/ and replace all \"(\" inside character sets.\n// Note: This method does not work for \"(\" that are escaped like this /\\x28/ or this /\\u0028/.\nPrism.languages.DFS(Prism.languages.racket, function (key, value) {\n\tif (Prism.util.type(value) === 'RegExp') {\n\t\tvar source = value.source.replace(/\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g, function (m, g1, g2) {\n\t\t\tif (g1) {\n\t\t\t\tif (g1 === '(') {\n\t\t\t\t\t// replace all '(' characters outside character sets\n\t\t\t\t\treturn '[([]';\n\t\t\t\t}\n\t\t\t\tif (g1 === ')') {\n\t\t\t\t\t// replace all ')' characters outside character sets\n\t\t\t\t\treturn '[)\\\\]]';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (g2) {\n\t\t\t\tvar prefix = m[1] === '^' ? '[^' : '[';\n\t\t\t\treturn prefix + g2.replace(/\\\\(.)|[()]/g, function (m, g1) {\n\t\t\t\t\tif (m === '(' || g1 === '(') {\n\t\t\t\t\t\t// replace all '(' characters inside character sets\n\t\t\t\t\t\treturn '([';\n\t\t\t\t\t}\n\t\t\t\t\tif (m === ')' || g1 === ')') {\n\t\t\t\t\t\t// replace all ')' characters inside character sets\n\t\t\t\t\t\treturn ')\\\\]';\n\t\t\t\t\t}\n\t\t\t\t\treturn m;\n\t\t\t\t}) + ']';\n\t\t\t}\n\t\t\treturn m;\n\t\t});\n\n\t\tthis[key] = RegExp(source, value.flags);\n\t}\n});\n\nPrism.languages.insertBefore('racket', 'string', {\n\t'lang': {\n\t\tpattern: /^#lang.+/m,\n\t\tgreedy: true,\n\t\talias: 'keyword'\n\t}\n});\n\nPrism.languages.rkt = Prism.languages.racket;\n"]}}