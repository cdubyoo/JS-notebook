{"code":"(this.webpackJsonpjbook=this.webpackJsonpjbook||[]).push([[249],{417:function(e,n){!function(e){function n(e,n){return\"___\"+e.toUpperCase()+n+\"___\"}Object.defineProperties(e.languages[\"markup-templating\"]={},{buildPlaceholders:{value:function(t,a,o,r){if(t.language===a){var c=t.tokenStack=[];t.code=t.code.replace(o,(function(e){if(\"function\"===typeof r&&!r(e))return e;for(var o,i=c.length;-1!==t.code.indexOf(o=n(a,i));)++i;return c[i]=e,o})),t.grammar=e.languages.markup}}},tokenizePlaceholders:{value:function(t,a){if(t.language===a&&t.tokenStack){t.grammar=e.languages[a];var o=0,r=Object.keys(t.tokenStack);!function c(i){for(var u=0;u<i.length&&!(o>=r.length);u++){var s=i[u];if(\"string\"===typeof s||s.content&&\"string\"===typeof s.content){var p=r[o],g=t.tokenStack[p],l=\"string\"===typeof s?s:s.content,f=n(a,p),k=l.indexOf(f);if(k>-1){++o;var h=l.substring(0,k),m=new e.Token(a,e.tokenize(g,t.grammar),\"language-\"+a,g),b=l.substring(k+f.length),d=[];h&&d.push.apply(d,c([h])),d.push(m),b&&d.push.apply(d,c([b])),\"string\"===typeof s?i.splice.apply(i,[u,1].concat(d)):s.content=d}}else s.content&&c(s.content)}return i}(t.tokens)}}}})}(Prism)}}]);","name":"static/js/249.6915bef8.chunk.js","map":{"version":3,"sources":["static/js/249.6915bef8.chunk.js"],"names":["this","push","417","module","exports","Prism","getPlaceholder","language","index","toUpperCase","Object","defineProperties","languages","buildPlaceholders","value","env","placeholderPattern","replaceFilter","tokenStack","code","replace","match","placeholder","i","length","indexOf","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","before","substring","middle","Token","tokenize","after","replacement","apply","splice","concat"],"mappings":"CAACA,KAAwB,kBAAIA,KAAwB,mBAAK,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEpEC,IACA,SAAUC,EAAQC,IAExB,SAAWC,GAQT,SAASC,EAAeC,EAAUC,GAChC,MAAO,MAAQD,EAASE,cAAgBD,EAAQ,MAGlDE,OAAOC,iBAAiBN,EAAMO,UAAU,qBAAuB,GAAI,CACjEC,kBAAmB,CAYjBC,MAAO,SAAeC,EAAKR,EAAUS,EAAoBC,GACvD,GAAIF,EAAIR,WAAaA,EAArB,CAIA,IAAIW,EAAaH,EAAIG,WAAa,GAClCH,EAAII,KAAOJ,EAAII,KAAKC,QAAQJ,GAAoB,SAAUK,GACxD,GAA6B,oBAAlBJ,IAAiCA,EAAcI,GACxD,OAAOA,EAMT,IAHA,IACIC,EADAC,EAAIL,EAAWM,QAGqD,IAAjET,EAAII,KAAKM,QAAQH,EAAchB,EAAeC,EAAUgB,OAC3DA,EAKJ,OADAL,EAAWK,GAAKF,EACTC,KAGTP,EAAIW,QAAUrB,EAAMO,UAAUe,UAGlCC,qBAAsB,CAOpBd,MAAO,SAAeC,EAAKR,GACzB,GAAIQ,EAAIR,WAAaA,GAAaQ,EAAIG,WAAtC,CAKAH,EAAIW,QAAUrB,EAAMO,UAAUL,GAC9B,IAAIsB,EAAI,EACJC,EAAOpB,OAAOoB,KAAKf,EAAIG,aAE3B,SAASa,EAAWC,GAClB,IAAK,IAAIT,EAAI,EAAGA,EAAIS,EAAOR,UAErBK,GAAKC,EAAKN,QAFmBD,IAAK,CAMtC,IAAIU,EAAQD,EAAOT,GAEnB,GAAqB,kBAAVU,GAAsBA,EAAMC,SAAoC,kBAAlBD,EAAMC,QAAsB,CACnF,IAAIC,EAAIL,EAAKD,GACTO,EAAIrB,EAAIG,WAAWiB,GACnBE,EAAqB,kBAAVJ,EAAqBA,EAAQA,EAAMC,QAC9CZ,EAAchB,EAAeC,EAAU4B,GACvC3B,EAAQ6B,EAAEZ,QAAQH,GAEtB,GAAId,GAAS,EAAG,GACZqB,EACF,IAAIS,EAASD,EAAEE,UAAU,EAAG/B,GACxBgC,EAAS,IAAInC,EAAMoC,MAAMlC,EAAUF,EAAMqC,SAASN,EAAGrB,EAAIW,SAAU,YAAcnB,EAAU6B,GAC3FO,EAAQN,EAAEE,UAAU/B,EAAQc,EAAYE,QACxCoB,EAAc,GAEdN,GACFM,EAAY3C,KAAK4C,MAAMD,EAAab,EAAW,CAACO,KAGlDM,EAAY3C,KAAKuC,GAEbG,GACFC,EAAY3C,KAAK4C,MAAMD,EAAab,EAAW,CAACY,KAG7B,kBAAVV,EACTD,EAAOc,OAAOD,MAAMb,EAAQ,CAACT,EAAG,GAAGwB,OAAOH,IAE1CX,EAAMC,QAAUU,QAGXX,EAAMC,SAGbH,EAAWE,EAAMC,SAIvB,OAAOF,EAGTD,CAAWhB,EAAIiB,aArHvB,CAyHG3B"},"input":"(this[\"webpackJsonpjbook\"] = this[\"webpackJsonpjbook\"] || []).push([[249],{\n\n/***/ 417:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */\n  function getPlaceholder(language, index) {\n    return '___' + language.toUpperCase() + index + '___';\n  }\n\n  Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n    buildPlaceholders: {\n      /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */\n      value: function value(env, language, placeholderPattern, replaceFilter) {\n        if (env.language !== language) {\n          return;\n        }\n\n        var tokenStack = env.tokenStack = [];\n        env.code = env.code.replace(placeholderPattern, function (match) {\n          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n            return match;\n          }\n\n          var i = tokenStack.length;\n          var placeholder; // Check for existing strings\n\n          while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n            ++i;\n          } // Create a sparse array\n\n\n          tokenStack[i] = match;\n          return placeholder;\n        }); // Switch the grammar to markup\n\n        env.grammar = Prism.languages.markup;\n      }\n    },\n    tokenizePlaceholders: {\n      /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */\n      value: function value(env, language) {\n        if (env.language !== language || !env.tokenStack) {\n          return;\n        } // Switch the grammar back\n\n\n        env.grammar = Prism.languages[language];\n        var j = 0;\n        var keys = Object.keys(env.tokenStack);\n\n        function walkTokens(tokens) {\n          for (var i = 0; i < tokens.length; i++) {\n            // all placeholders are replaced already\n            if (j >= keys.length) {\n              break;\n            }\n\n            var token = tokens[i];\n\n            if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n              var k = keys[j];\n              var t = env.tokenStack[k];\n              var s = typeof token === 'string' ? token : token.content;\n              var placeholder = getPlaceholder(language, k);\n              var index = s.indexOf(placeholder);\n\n              if (index > -1) {\n                ++j;\n                var before = s.substring(0, index);\n                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                var after = s.substring(index + placeholder.length);\n                var replacement = [];\n\n                if (before) {\n                  replacement.push.apply(replacement, walkTokens([before]));\n                }\n\n                replacement.push(middle);\n\n                if (after) {\n                  replacement.push.apply(replacement, walkTokens([after]));\n                }\n\n                if (typeof token === 'string') {\n                  tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                } else {\n                  token.content = replacement;\n                }\n              }\n            } else if (token.content\n            /* && typeof token.content !== 'string' */\n            ) {\n                walkTokens(token.content);\n              }\n          }\n\n          return tokens;\n        }\n\n        walkTokens(env.tokens);\n      }\n    }\n  });\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/User/Desktop/jbook/node_modules/prismjs/components/prism-markup-templating.js"],"names":["Prism","getPlaceholder","language","index","toUpperCase","Object","defineProperties","languages","buildPlaceholders","value","env","placeholderPattern","replaceFilter","tokenStack","code","replace","match","i","length","placeholder","indexOf","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","before","substring","middle","Token","tokenize","after","replacement","push","apply","splice","concat"],"mappings":"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","file":"x","sourcesContent":["(function (Prism) {\n\n\t/**\n\t * Returns the placeholder for the given language id and index.\n\t *\n\t * @param {string} language\n\t * @param {string|number} index\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(language, index) {\n\t\treturn '___' + language.toUpperCase() + index + '___';\n\t}\n\n\tObject.defineProperties(Prism.languages['markup-templating'] = {}, {\n\t\tbuildPlaceholders: {\n\t\t\t/**\n\t\t\t * Tokenize all inline templating expressions matching `placeholderPattern`.\n\t\t\t *\n\t\t\t * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n\t\t\t * `true` will be replaced.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `before-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n\t\t\t * @param {(match: string) => boolean} [replaceFilter]\n\t\t\t */\n\t\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\t\tif (env.language !== language) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar tokenStack = env.tokenStack = [];\n\n\t\t\t\tenv.code = env.code.replace(placeholderPattern, function (match) {\n\t\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = tokenStack.length;\n\t\t\t\t\tvar placeholder;\n\n\t\t\t\t\t// Check for existing strings\n\t\t\t\t\twhile (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1)\n\t\t\t\t\t\t++i;\n\n\t\t\t\t\t// Create a sparse array\n\t\t\t\t\ttokenStack[i] = match;\n\n\t\t\t\t\treturn placeholder;\n\t\t\t\t});\n\n\t\t\t\t// Switch the grammar to markup\n\t\t\t\tenv.grammar = Prism.languages.markup;\n\t\t\t}\n\t\t},\n\t\ttokenizePlaceholders: {\n\t\t\t/**\n\t\t\t * Replace placeholders with proper tokens after tokenizing.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `after-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t */\n\t\t\tvalue: function (env, language) {\n\t\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Switch the grammar back\n\t\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\t\tvar j = 0;\n\t\t\t\tvar keys = Object.keys(env.tokenStack);\n\n\t\t\t\tfunction walkTokens(tokens) {\n\t\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\t\t// all placeholders are replaced already\n\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\t\t\t\t\t\t\tvar placeholder = getPlaceholder(language, k);\n\n\t\t\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t\t++j;\n\n\t\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n\t\t\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([before]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([after]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (token.content /* && typeof token.content !== 'string' */) {\n\t\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t}\n\n\t\t\t\twalkTokens(env.tokens);\n\t\t\t}\n\t\t}\n\t});\n\n}(Prism));\n"]}}