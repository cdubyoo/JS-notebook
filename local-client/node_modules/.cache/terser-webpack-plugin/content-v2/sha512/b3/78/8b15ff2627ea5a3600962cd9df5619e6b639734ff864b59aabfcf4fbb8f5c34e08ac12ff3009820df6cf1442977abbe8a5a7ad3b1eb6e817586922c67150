{"code":"(this.webpackJsonpjbook=this.webpackJsonpjbook||[]).push([[270],{438:function(e,a){!function(e){var a=/\\{[^\\r\\n\\[\\]{}]*\\}/,n={\"quoted-string\":{pattern:/\"(?:[^\"\\\\]|\\\\.)*\"/,alias:\"operator\"},\"command-param-id\":{pattern:/(\\s)\\w+:/,lookbehind:!0,alias:\"property\"},\"command-param-value\":[{pattern:a,alias:\"selector\"},{pattern:/([\\t ])\\S+/,lookbehind:!0,greedy:!0,alias:\"operator\"},{pattern:/\\S(?:.*\\S)?/,alias:\"operator\"}]};function t(e){return\"string\"===typeof e?e:Array.isArray(e)?e.map(t).join(\"\"):t(e.content)}e.languages.naniscript={comment:{pattern:/^([\\t ]*);.*/m,lookbehind:!0},define:{pattern:/^>.+/m,alias:\"tag\",inside:{value:{pattern:/(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,lookbehind:!0,alias:\"operator\"},key:{pattern:/(^>)\\w+/,lookbehind:!0}}},label:{pattern:/^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,lookbehind:!0,alias:\"regex\"},command:{pattern:/^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,lookbehind:!0,alias:\"function\",inside:{\"command-name\":/^@\\w+/,expression:{pattern:a,greedy:!0,alias:\"selector\"},\"command-params\":{pattern:/[\\s\\S]*\\S[\\s\\S]*/,inside:n}}},\"generic-text\":{pattern:/(^[ \\t]*)[^#@>;\\s].*/m,lookbehind:!0,alias:\"punctuation\",inside:{\"escaped-char\":/\\\\[{}\\[\\]\"]/,expression:{pattern:a,greedy:!0,alias:\"selector\"},\"inline-command\":{pattern:/\\[[\\t ]*\\w+[^\\r\\n\\[\\]]*\\]/,greedy:!0,alias:\"function\",inside:{\"command-params\":{pattern:/(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,lookbehind:!0,inside:n},\"command-param-name\":{pattern:/^(\\[[\\t ]*)\\w+/,lookbehind:!0,alias:\"name\"},\"start-stop-char\":/[\\[\\]]/}}}}},e.languages.nani=e.languages.naniscript,e.hooks.add(\"after-tokenize\",(function(e){e.tokens.forEach((function(e){if(\"string\"!==typeof e&&\"generic-text\"===e.type){var a=t(e);(function(e){for(var a=\"[]{}\",n=[],t=0;t<e.length;t++){var r=e[t],i=a.indexOf(r);if(-1!==i)if(i%2===0)n.push(i+1);else if(n.pop()!==i)return!1}return 0===n.length})(a)||(e.type=\"bad-line\",e.content=a)}}))}))}(Prism)}}]);","name":"static/js/270.0de29940.chunk.js","map":{"version":3,"sources":["static/js/270.0de29940.chunk.js"],"names":["this","push","438","module","exports","Prism","expressionDef","params","quoted-string","pattern","alias","command-param-id","lookbehind","command-param-value","greedy","getTextContent","token","Array","isArray","map","join","content","languages","naniscript","comment","define","inside","value","key","label","command","command-name","expression","command-params","generic-text","escaped-char","inline-command","command-param-name","start-stop-char","nani","hooks","add","env","tokens","forEach","type","input","brackets","stack","i","length","bracket","bracketsIndex","indexOf","pop","isBracketsBalanced"],"mappings":"CAACA,KAAwB,kBAAIA,KAAwB,mBAAK,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEpEC,IACA,SAAUC,EAAQC,IAExB,SAAWC,GACT,IAAIC,EAAgB,qBAChBC,EAAS,CACXC,gBAAiB,CACfC,QAAS,oBACTC,MAAO,YAETC,mBAAoB,CAClBF,QAAS,WACTG,YAAY,EACZF,MAAO,YAETG,sBAAuB,CAAC,CACtBJ,QAASH,EACTI,MAAO,YACN,CACDD,QAAS,aACTG,YAAY,EACZE,QAAQ,EACRJ,MAAO,YACN,CACDD,QAAS,cACTC,MAAO,cAwIX,SAASK,EAAeC,GACtB,MAAqB,kBAAVA,EACFA,EACEC,MAAMC,QAAQF,GAChBA,EAAMG,IAAIJ,GAAgBK,KAAK,IAE/BL,EAAeC,EAAMK,SA3IhChB,EAAMiB,UAAUC,WAAa,CAE3BC,QAAW,CACTf,QAAS,gBACTG,YAAY,GAIda,OAAU,CACRhB,QAAS,QACTC,MAAO,MACPgB,OAAQ,CACNC,MAAS,CACPlB,QAAS,gCACTG,YAAY,EACZF,MAAO,YAETkB,IAAO,CACLnB,QAAS,UACTG,YAAY,KAKlBiB,MAAS,CACPpB,QAAS,8BACTG,YAAY,EACZF,MAAO,SAEToB,QAAW,CACTrB,QAAS,8BACTG,YAAY,EACZF,MAAO,WACPgB,OAAQ,CACNK,eAAgB,QAChBC,WAAc,CACZvB,QAASH,EACTQ,QAAQ,EACRJ,MAAO,YAETuB,iBAAkB,CAChBxB,QAAS,mBACTiB,OAAQnB,KAKd2B,eAAgB,CACdzB,QAAS,wBACTG,YAAY,EACZF,MAAO,cACPgB,OAAQ,CAENS,eAAgB,cAChBH,WAAc,CACZvB,QAASH,EACTQ,QAAQ,EACRJ,MAAO,YAET0B,iBAAkB,CAChB3B,QAAS,4BACTK,QAAQ,EACRJ,MAAO,WACPgB,OAAQ,CACNO,iBAAkB,CAChBxB,QAAS,iCACTG,YAAY,EACZc,OAAQnB,GAEV8B,qBAAsB,CACpB5B,QAAS,iBACTG,YAAY,EACZF,MAAO,QAET4B,kBAAmB,cAM7BjC,EAAMiB,UAAUiB,KAAOlC,EAAMiB,UAAsB,WAQnDjB,EAAMmC,MAAMC,IAAI,kBAAkB,SAAUC,GAE7BA,EAAIC,OACVC,SAAQ,SAAU5B,GACvB,GAAqB,kBAAVA,GAAqC,iBAAfA,EAAM6B,KAAyB,CAC9D,IAAIxB,EAAUN,EAAeC,IAcnC,SAA4B8B,GAI1B,IAHA,IAAIC,EAAW,OACXC,EAAQ,GAEHC,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,IAAK,CACrC,IAAIE,EAAUL,EAAMG,GAChBG,EAAgBL,EAASM,QAAQF,GAErC,IAAuB,IAAnBC,EACF,GAAIA,EAAgB,IAAM,EACxBJ,EAAM/C,KAAKmD,EAAgB,QACtB,GAAIJ,EAAMM,QAAUF,EACzB,OAAO,EAKb,OAAwB,IAAjBJ,EAAME,QA7BJK,CAAmBlC,KACtBL,EAAM6B,KAAO,WACb7B,EAAMK,QAAUA,UA1H1B,CAuKGhB"},"input":"(this[\"webpackJsonpjbook\"] = this[\"webpackJsonpjbook\"] || []).push([[270],{\n\n/***/ 438:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  var expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n  var params = {\n    'quoted-string': {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      alias: 'operator'\n    },\n    'command-param-id': {\n      pattern: /(\\s)\\w+:/,\n      lookbehind: true,\n      alias: 'property'\n    },\n    'command-param-value': [{\n      pattern: expressionDef,\n      alias: 'selector'\n    }, {\n      pattern: /([\\t ])\\S+/,\n      lookbehind: true,\n      greedy: true,\n      alias: 'operator'\n    }, {\n      pattern: /\\S(?:.*\\S)?/,\n      alias: 'operator'\n    }]\n  };\n  Prism.languages.naniscript = {\n    // ; ...\n    'comment': {\n      pattern: /^([\\t ]*);.*/m,\n      lookbehind: true\n    },\n    // > ...\n    // Define is a control line starting with '>' followed by a word, a space and a text.\n    'define': {\n      pattern: /^>.+/m,\n      alias: 'tag',\n      inside: {\n        'value': {\n          pattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n          lookbehind: true,\n          alias: 'operator'\n        },\n        'key': {\n          pattern: /(^>)\\w+/,\n          lookbehind: true\n        }\n      }\n    },\n    // # ...\n    'label': {\n      pattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n      lookbehind: true,\n      alias: 'regex'\n    },\n    'command': {\n      pattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n      lookbehind: true,\n      alias: 'function',\n      inside: {\n        'command-name': /^@\\w+/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'command-params': {\n          pattern: /[\\s\\S]*\\S[\\s\\S]*/,\n          inside: params\n        }\n      }\n    },\n    // Generic is any line that doesn't start with operators: ;>#@\n    'generic-text': {\n      pattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n      lookbehind: true,\n      alias: 'punctuation',\n      inside: {\n        // \\{ ... \\} ... \\[ ... \\] ... \\\"\n        'escaped-char': /\\\\[{}\\[\\]\"]/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'inline-command': {\n          pattern: /\\[[\\t ]*\\w+[^\\r\\n\\[\\]]*\\]/,\n          greedy: true,\n          alias: 'function',\n          inside: {\n            'command-params': {\n              pattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n              lookbehind: true,\n              inside: params\n            },\n            'command-param-name': {\n              pattern: /^(\\[[\\t ]*)\\w+/,\n              lookbehind: true,\n              alias: 'name'\n            },\n            'start-stop-char': /[\\[\\]]/\n          }\n        }\n      }\n    }\n  };\n  Prism.languages.nani = Prism.languages['naniscript'];\n  /** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n  /**\n   * This hook is used to validate generic-text tokens for balanced brackets.\n   * Mark token as bad-line when contains not balanced brackets: {},[]\n   */\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    /** @type {(Token | string)[]} */\n    var tokens = env.tokens;\n    tokens.forEach(function (token) {\n      if (typeof token !== \"string\" && token.type === 'generic-text') {\n        var content = getTextContent(token);\n\n        if (!isBracketsBalanced(content)) {\n          token.type = 'bad-line';\n          token.content = content;\n        }\n      }\n    });\n  });\n  /**\n   * @param {string} input\n   * @returns {boolean}\n   */\n\n  function isBracketsBalanced(input) {\n    var brackets = \"[]{}\";\n    var stack = [];\n\n    for (var i = 0; i < input.length; i++) {\n      var bracket = input[i];\n      var bracketsIndex = brackets.indexOf(bracket);\n\n      if (bracketsIndex !== -1) {\n        if (bracketsIndex % 2 === 0) {\n          stack.push(bracketsIndex + 1);\n        } else if (stack.pop() !== bracketsIndex) {\n          return false;\n        }\n      }\n    }\n\n    return stack.length === 0;\n  }\n\n  ;\n  /**\n   * @param {string | Token | (string | Token)[]} token\n   * @returns {string}\n   */\n\n  function getTextContent(token) {\n    if (typeof token === 'string') {\n      return token;\n    } else if (Array.isArray(token)) {\n      return token.map(getTextContent).join('');\n    } else {\n      return getTextContent(token.content);\n    }\n  }\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:/Users/User/Desktop/jbook/node_modules/prismjs/components/prism-naniscript.js"],"names":["Prism","expressionDef","params","pattern","alias","lookbehind","greedy","languages","naniscript","inside","nani","hooks","add","env","tokens","forEach","token","type","content","getTextContent","isBracketsBalanced","input","brackets","stack","i","length","bracket","bracketsIndex","indexOf","push","pop","Array","isArray","map","join"],"mappings":";;;;;AAAA,CAAC,UAAUA,KAAV,EAAiB;AAEjB,MAAIC,aAAa,GAAG,oBAApB;AAEA,MAAIC,MAAM,GAAG;AACZ,qBAAiB;AAChBC,aAAO,EAAE,mBADO;AAEhBC,WAAK,EAAE;AAFS,KADL;AAKZ,wBAAoB;AACnBD,aAAO,EAAE,UADU;AAEnBE,gBAAU,EAAE,IAFO;AAGnBD,WAAK,EAAE;AAHY,KALR;AAUZ,2BAAuB,CACtB;AACCD,aAAO,EAAEF,aADV;AAECG,WAAK,EAAE;AAFR,KADsB,EAKtB;AACCD,aAAO,EAAE,YADV;AAECE,gBAAU,EAAE,IAFb;AAGCC,YAAM,EAAE,IAHT;AAICF,WAAK,EAAE;AAJR,KALsB,EAWtB;AACCD,aAAO,EAAE,aADV;AAECC,WAAK,EAAE;AAFR,KAXsB;AAVX,GAAb;AA4BAJ,OAAK,CAACO,SAAN,CAAgBC,UAAhB,GAA6B;AAC5B;AACA,eAAW;AACVL,aAAO,EAAE,eADC;AAEVE,gBAAU,EAAE;AAFF,KAFiB;AAM5B;AACA;AACA,cAAU;AACTF,aAAO,EAAE,OADA;AAETC,WAAK,EAAE,KAFE;AAGTK,YAAM,EAAE;AACP,iBAAS;AACRN,iBAAO,EAAE,+BADD;AAERE,oBAAU,EAAE,IAFJ;AAGRD,eAAK,EAAE;AAHC,SADF;AAMP,eAAO;AACND,iBAAO,EAAE,SADH;AAENE,oBAAU,EAAE;AAFN;AANA;AAHC,KARkB;AAuB5B;AACA,aAAS;AACRF,aAAO,EAAE,6BADD;AAERE,gBAAU,EAAE,IAFJ;AAGRD,WAAK,EAAE;AAHC,KAxBmB;AA6B5B,eAAW;AACVD,aAAO,EAAE,6BADC;AAEVE,gBAAU,EAAE,IAFF;AAGVD,WAAK,EAAE,UAHG;AAIVK,YAAM,EAAE;AACP,wBAAgB,OADT;AAEP,sBAAc;AACbN,iBAAO,EAAEF,aADI;AAEbK,gBAAM,EAAE,IAFK;AAGbF,eAAK,EAAE;AAHM,SAFP;AAOP,0BAAkB;AACjBD,iBAAO,EAAE,kBADQ;AAEjBM,gBAAM,EAAEP;AAFS;AAPX;AAJE,KA7BiB;AA8C5B;AACA,oBAAgB;AACfC,aAAO,EAAE,uBADM;AAEfE,gBAAU,EAAE,IAFG;AAGfD,WAAK,EAAE,aAHQ;AAIfK,YAAM,EAAE;AACP;AACA,wBAAgB,aAFT;AAGP,sBAAc;AACbN,iBAAO,EAAEF,aADI;AAEbK,gBAAM,EAAE,IAFK;AAGbF,eAAK,EAAE;AAHM,SAHP;AAQP,0BAAkB;AACjBD,iBAAO,EAAE,2BADQ;AAEjBG,gBAAM,EAAE,IAFS;AAGjBF,eAAK,EAAE,UAHU;AAIjBK,gBAAM,EAAE;AACP,8BAAkB;AACjBN,qBAAO,EAAE,gCADQ;AAEjBE,wBAAU,EAAE,IAFK;AAGjBI,oBAAM,EAAEP;AAHS,aADX;AAMP,kCAAsB;AACrBC,qBAAO,EAAE,gBADY;AAErBE,wBAAU,EAAE,IAFS;AAGrBD,mBAAK,EAAE;AAHc,aANf;AAWP,+BAAmB;AAXZ;AAJS;AARX;AAJO;AA/CY,GAA7B;AAgFAJ,OAAK,CAACO,SAAN,CAAgBG,IAAhB,GAAuBV,KAAK,CAACO,SAAN,CAAgB,YAAhB,CAAvB;AAEA;;AAEA;AACD;AACA;AACA;;AACCP,OAAK,CAACW,KAAN,CAAYC,GAAZ,CAAgB,gBAAhB,EAAkC,UAAUC,GAAV,EAAe;AAChD;AACA,QAAIC,MAAM,GAAGD,GAAG,CAACC,MAAjB;AACAA,UAAM,CAACC,OAAP,CAAe,UAAUC,KAAV,EAAiB;AAC/B,UAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACC,IAAN,KAAe,cAAhD,EAAgE;AAC/D,YAAIC,OAAO,GAAGC,cAAc,CAACH,KAAD,CAA5B;;AACA,YAAI,CAACI,kBAAkB,CAACF,OAAD,CAAvB,EAAkC;AACjCF,eAAK,CAACC,IAAN,GAAa,UAAb;AACAD,eAAK,CAACE,OAAN,GAAgBA,OAAhB;AACA;AACD;AACD,KARD;AASA,GAZD;AAcA;AACD;AACA;AACA;;AACC,WAASE,kBAAT,CAA4BC,KAA5B,EAAmC;AAClC,QAAIC,QAAQ,GAAG,MAAf;AACA,QAAIC,KAAK,GAAG,EAAZ;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACtC,UAAIE,OAAO,GAAGL,KAAK,CAACG,CAAD,CAAnB;AACA,UAAIG,aAAa,GAAGL,QAAQ,CAACM,OAAT,CAAiBF,OAAjB,CAApB;;AACA,UAAIC,aAAa,KAAK,CAAC,CAAvB,EAA0B;AACzB,YAAIA,aAAa,GAAG,CAAhB,KAAsB,CAA1B,EAA6B;AAC5BJ,eAAK,CAACM,IAAN,CAAWF,aAAa,GAAG,CAA3B;AACA,SAFD,MAEO,IAAIJ,KAAK,CAACO,GAAN,OAAgBH,aAApB,EAAmC;AACzC,iBAAO,KAAP;AACA;AACD;AACD;;AACD,WAAOJ,KAAK,CAACE,MAAN,KAAiB,CAAxB;AACA;;AAAA;AAED;AACD;AACA;AACA;;AACC,WAASN,cAAT,CAAwBH,KAAxB,EAA+B;AAC9B,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC9B,aAAOA,KAAP;AACA,KAFD,MAEO,IAAIe,KAAK,CAACC,OAAN,CAAchB,KAAd,CAAJ,EAA0B;AAChC,aAAOA,KAAK,CAACiB,GAAN,CAAUd,cAAV,EAA0Be,IAA1B,CAA+B,EAA/B,CAAP;AACA,KAFM,MAEA;AACN,aAAOf,cAAc,CAACH,KAAK,CAACE,OAAP,CAArB;AACA;AACD;AAED,CAzKD,EAyKGlB,KAzKH,E","file":"x","sourcesContent":["(function (Prism) {\n\n\tvar expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n\n\tvar params = {\n\t\t'quoted-string': {\n\t\t\tpattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\talias: 'operator'\n\t\t},\n\t\t'command-param-id': {\n\t\t\tpattern: /(\\s)\\w+:/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'property'\n\t\t},\n\t\t'command-param-value': [\n\t\t\t{\n\t\t\t\tpattern: expressionDef,\n\t\t\t\talias: 'selector',\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /([\\t ])\\S+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\talias: 'operator',\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\S(?:.*\\S)?/,\n\t\t\t\talias: 'operator',\n\t\t\t}\n\t\t]\n\t};\n\n\tPrism.languages.naniscript = {\n\t\t// ; ...\n\t\t'comment': {\n\t\t\tpattern: /^([\\t ]*);.*/m,\n\t\t\tlookbehind: true,\n\t\t},\n\t\t// > ...\n\t\t// Define is a control line starting with '>' followed by a word, a space and a text.\n\t\t'define': {\n\t\t\tpattern: /^>.+/m,\n\t\t\talias: 'tag',\n\t\t\tinside: {\n\t\t\t\t'value': {\n\t\t\t\t\tpattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'key': {\n\t\t\t\t\tpattern: /(^>)\\w+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// # ...\n\t\t'label': {\n\t\t\tpattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'regex'\n\t\t},\n\t\t'command': {\n\t\t\tpattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function',\n\t\t\tinside: {\n\t\t\t\t'command-name': /^@\\w+/,\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: expressionDef,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'command-params': {\n\t\t\t\t\tpattern: /[\\s\\S]*\\S[\\s\\S]*/,\n\t\t\t\t\tinside: params\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t// Generic is any line that doesn't start with operators: ;>#@\n\t\t'generic-text': {\n\t\t\tpattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation',\n\t\t\tinside: {\n\t\t\t\t// \\{ ... \\} ... \\[ ... \\] ... \\\"\n\t\t\t\t'escaped-char': /\\\\[{}\\[\\]\"]/,\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: expressionDef,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'inline-command': {\n\t\t\t\t\tpattern: /\\[[\\t ]*\\w+[^\\r\\n\\[\\]]*\\]/,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'function',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'command-params': {\n\t\t\t\t\t\t\tpattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\tinside: params\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'command-param-name': {\n\t\t\t\t\t\t\tpattern: /^(\\[[\\t ]*)\\w+/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: 'name',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'start-stop-char': /[\\[\\]]/,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t};\n\tPrism.languages.nani = Prism.languages['naniscript'];\n\n\t/** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n\t/**\n\t * This hook is used to validate generic-text tokens for balanced brackets.\n\t * Mark token as bad-line when contains not balanced brackets: {},[]\n\t */\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\t/** @type {(Token | string)[]} */\n\t\tvar tokens = env.tokens;\n\t\ttokens.forEach(function (token) {\n\t\t\tif (typeof token !== \"string\" && token.type === 'generic-text') {\n\t\t\t\tvar content = getTextContent(token);\n\t\t\t\tif (!isBracketsBalanced(content)) {\n\t\t\t\t\ttoken.type = 'bad-line';\n\t\t\t\t\ttoken.content = content;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\t/**\n\t * @param {string} input\n\t * @returns {boolean}\n\t */\n\tfunction isBracketsBalanced(input) {\n\t\tvar brackets = \"[]{}\";\n\t\tvar stack = [];\n\t\tfor (var i = 0; i < input.length; i++) {\n\t\t\tvar bracket = input[i];\n\t\t\tvar bracketsIndex = brackets.indexOf(bracket);\n\t\t\tif (bracketsIndex !== -1) {\n\t\t\t\tif (bracketsIndex % 2 === 0) {\n\t\t\t\t\tstack.push(bracketsIndex + 1);\n\t\t\t\t} else if (stack.pop() !== bracketsIndex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stack.length === 0;\n\t};\n\n\t/**\n\t * @param {string | Token | (string | Token)[]} token\n\t * @returns {string}\n\t */\n\tfunction getTextContent(token) {\n\t\tif (typeof token === 'string') {\n\t\t\treturn token;\n\t\t} else if (Array.isArray(token)) {\n\t\t\treturn token.map(getTextContent).join('');\n\t\t} else {\n\t\t\treturn getTextContent(token.content);\n\t\t}\n\t}\n\n})(Prism);\n"]}}