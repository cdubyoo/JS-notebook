{"ast":null,"code":"Prism.languages.racket = Prism.languages.extend('scheme', {\n  'lambda-parameter': {\n    // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.\n    // this will just prevent false positives of the `function` pattern\n    pattern: /(\\(lambda\\s+\\()[^()'\\s]+/,\n    lookbehind: true\n  }\n}); // Add brackets to racket\n// The basic idea here is to go through all pattens of Scheme and replace all occurrences of \"(\" with the union of \"(\"\n// and \"[\"; Similar for \")\". This is a bit tricky because \"(\" can be escaped or inside a character set. Both cases\n// have to be handled differently and, of course, we don't want to destroy groups, so we can only replace literal \"(\"\n// and \")\".\n// To do this, we use a regular expression which will parse any JS regular expression. It works because regexes are\n// matches from left to right and already matched text cannot be matched again. We use this to first capture all\n// escaped characters (not really, we don't get escape sequences but we don't need them). Because we already captured\n// all escaped characters, we know that any \"[\" character is the start of a character set, so we match that character\n// set whole.\n// With the regex parsed, we only have to replace all escaped \"(\" (they cannot be unescaped outside of character sets)\n// with /[([]/ and replace all \"(\" inside character sets.\n// Note: This method does not work for \"(\" that are escaped like this /\\x28/ or this /\\u0028/.\n\nPrism.languages.DFS(Prism.languages.racket, function (key, value) {\n  if (Prism.util.type(value) === 'RegExp') {\n    var source = value.source.replace(/\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g, function (m, g1, g2) {\n      if (g1) {\n        if (g1 === '(') {\n          // replace all '(' characters outside character sets\n          return '[([]';\n        }\n\n        if (g1 === ')') {\n          // replace all ')' characters outside character sets\n          return '[)\\\\]]';\n        }\n      }\n\n      if (g2) {\n        var prefix = m[1] === '^' ? '[^' : '[';\n        return prefix + g2.replace(/\\\\(.)|[()]/g, function (m, g1) {\n          if (m === '(' || g1 === '(') {\n            // replace all '(' characters inside character sets\n            return '([';\n          }\n\n          if (m === ')' || g1 === ')') {\n            // replace all ')' characters inside character sets\n            return ')\\\\]';\n          }\n\n          return m;\n        }) + ']';\n      }\n\n      return m;\n    });\n    this[key] = RegExp(source, value.flags);\n  }\n});\nPrism.languages.insertBefore('racket', 'string', {\n  'lang': {\n    pattern: /^#lang.+/m,\n    greedy: true,\n    alias: 'keyword'\n  }\n});\nPrism.languages.rkt = Prism.languages.racket;","map":{"version":3,"sources":["C:/Users/User/Desktop/jbook/node_modules/prismjs/components/prism-racket.js"],"names":["Prism","languages","racket","extend","pattern","lookbehind","DFS","key","value","util","type","source","replace","m","g1","g2","prefix","RegExp","flags","insertBefore","greedy","alias","rkt"],"mappings":"AAAAA,KAAK,CAACC,SAAN,CAAgBC,MAAhB,GAAyBF,KAAK,CAACC,SAAN,CAAgBE,MAAhB,CAAuB,QAAvB,EAAiC;AACzD,sBAAoB;AACnB;AACA;AACAC,IAAAA,OAAO,EAAE,0BAHU;AAInBC,IAAAA,UAAU,EAAE;AAJO;AADqC,CAAjC,CAAzB,C,CASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAL,KAAK,CAACC,SAAN,CAAgBK,GAAhB,CAAoBN,KAAK,CAACC,SAAN,CAAgBC,MAApC,EAA4C,UAAUK,GAAV,EAAeC,KAAf,EAAsB;AACjE,MAAIR,KAAK,CAACS,IAAN,CAAWC,IAAX,CAAgBF,KAAhB,MAA2B,QAA/B,EAAyC;AACxC,QAAIG,MAAM,GAAGH,KAAK,CAACG,MAAN,CAAaC,OAAb,CAAqB,kCAArB,EAAyD,UAAUC,CAAV,EAAaC,EAAb,EAAiBC,EAAjB,EAAqB;AAC1F,UAAID,EAAJ,EAAQ;AACP,YAAIA,EAAE,KAAK,GAAX,EAAgB;AACf;AACA,iBAAO,MAAP;AACA;;AACD,YAAIA,EAAE,KAAK,GAAX,EAAgB;AACf;AACA,iBAAO,QAAP;AACA;AACD;;AACD,UAAIC,EAAJ,EAAQ;AACP,YAAIC,MAAM,GAAGH,CAAC,CAAC,CAAD,CAAD,KAAS,GAAT,GAAe,IAAf,GAAsB,GAAnC;AACA,eAAOG,MAAM,GAAGD,EAAE,CAACH,OAAH,CAAW,aAAX,EAA0B,UAAUC,CAAV,EAAaC,EAAb,EAAiB;AAC1D,cAAID,CAAC,KAAK,GAAN,IAAaC,EAAE,KAAK,GAAxB,EAA6B;AAC5B;AACA,mBAAO,IAAP;AACA;;AACD,cAAID,CAAC,KAAK,GAAN,IAAaC,EAAE,KAAK,GAAxB,EAA6B;AAC5B;AACA,mBAAO,MAAP;AACA;;AACD,iBAAOD,CAAP;AACA,SAVe,CAAT,GAUF,GAVL;AAWA;;AACD,aAAOA,CAAP;AACA,KA1BY,CAAb;AA4BA,SAAKN,GAAL,IAAYU,MAAM,CAACN,MAAD,EAASH,KAAK,CAACU,KAAf,CAAlB;AACA;AACD,CAhCD;AAkCAlB,KAAK,CAACC,SAAN,CAAgBkB,YAAhB,CAA6B,QAA7B,EAAuC,QAAvC,EAAiD;AAChD,UAAQ;AACPf,IAAAA,OAAO,EAAE,WADF;AAEPgB,IAAAA,MAAM,EAAE,IAFD;AAGPC,IAAAA,KAAK,EAAE;AAHA;AADwC,CAAjD;AAQArB,KAAK,CAACC,SAAN,CAAgBqB,GAAhB,GAAsBtB,KAAK,CAACC,SAAN,CAAgBC,MAAtC","sourcesContent":["Prism.languages.racket = Prism.languages.extend('scheme', {\n\t'lambda-parameter': {\n\t\t// the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.\n\t\t// this will just prevent false positives of the `function` pattern\n\t\tpattern: /(\\(lambda\\s+\\()[^()'\\s]+/,\n\t\tlookbehind: true\n\t}\n});\n\n// Add brackets to racket\n// The basic idea here is to go through all pattens of Scheme and replace all occurrences of \"(\" with the union of \"(\"\n// and \"[\"; Similar for \")\". This is a bit tricky because \"(\" can be escaped or inside a character set. Both cases\n// have to be handled differently and, of course, we don't want to destroy groups, so we can only replace literal \"(\"\n// and \")\".\n// To do this, we use a regular expression which will parse any JS regular expression. It works because regexes are\n// matches from left to right and already matched text cannot be matched again. We use this to first capture all\n// escaped characters (not really, we don't get escape sequences but we don't need them). Because we already captured\n// all escaped characters, we know that any \"[\" character is the start of a character set, so we match that character\n// set whole.\n// With the regex parsed, we only have to replace all escaped \"(\" (they cannot be unescaped outside of character sets)\n// with /[([]/ and replace all \"(\" inside character sets.\n// Note: This method does not work for \"(\" that are escaped like this /\\x28/ or this /\\u0028/.\nPrism.languages.DFS(Prism.languages.racket, function (key, value) {\n\tif (Prism.util.type(value) === 'RegExp') {\n\t\tvar source = value.source.replace(/\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g, function (m, g1, g2) {\n\t\t\tif (g1) {\n\t\t\t\tif (g1 === '(') {\n\t\t\t\t\t// replace all '(' characters outside character sets\n\t\t\t\t\treturn '[([]';\n\t\t\t\t}\n\t\t\t\tif (g1 === ')') {\n\t\t\t\t\t// replace all ')' characters outside character sets\n\t\t\t\t\treturn '[)\\\\]]';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (g2) {\n\t\t\t\tvar prefix = m[1] === '^' ? '[^' : '[';\n\t\t\t\treturn prefix + g2.replace(/\\\\(.)|[()]/g, function (m, g1) {\n\t\t\t\t\tif (m === '(' || g1 === '(') {\n\t\t\t\t\t\t// replace all '(' characters inside character sets\n\t\t\t\t\t\treturn '([';\n\t\t\t\t\t}\n\t\t\t\t\tif (m === ')' || g1 === ')') {\n\t\t\t\t\t\t// replace all ')' characters inside character sets\n\t\t\t\t\t\treturn ')\\\\]';\n\t\t\t\t\t}\n\t\t\t\t\treturn m;\n\t\t\t\t}) + ']';\n\t\t\t}\n\t\t\treturn m;\n\t\t});\n\n\t\tthis[key] = RegExp(source, value.flags);\n\t}\n});\n\nPrism.languages.insertBefore('racket', 'string', {\n\t'lang': {\n\t\tpattern: /^#lang.+/m,\n\t\tgreedy: true,\n\t\talias: 'keyword'\n\t}\n});\n\nPrism.languages.rkt = Prism.languages.racket;\n"]},"metadata":{},"sourceType":"script"}